[09:00.000 --> 09:07.920]  que se direcciona en página, ¿cierto? Ahora, recuerden que algo que corresponde, algo que
[09:07.920 --> 09:12.480]  está acá tiene que corresponder algo que está en físico, y eso cómo se hace? Mediante la tabla
[09:12.480 --> 09:17.480]  de páginas, entonces uno salta, yo digo como, ah bueno, esta página tal está en el marco tal,
[09:17.480 --> 09:23.000]  entonces así se genera como cierta correspondencia entre lo virtual y lo físico. Entonces,
[09:23.000 --> 09:27.760]  ¿para qué les digo esto? Porque yo me imagino que si ustedes leyeron el enunciado, en serio,
[09:27.760 --> 09:31.720]  lo vamos a volver a leer igual, pero es para que si alguien tiene esa idea, pues no,
[09:31.720 --> 09:36.120]  sáquese de la cabeza, es que me imagino que ustedes pensaron que podían guardar en un array
[09:36.120 --> 09:42.640]  las cosas que les van saliendo, ¿sí? Y esto no se puede, ¿por qué? Porque el profesor quiere
[09:42.640 --> 09:48.720]  que ustedes guarden en la memoria esas cositas, literalmente tienen que guardar todo con punteros,
[09:48.720 --> 09:53.120]  y eso era lo que yo estaba diciendo que había en el grupo, y ya les voy a mostrar cómo se hace,
[09:53.680 --> 09:59.560]  obviamente, pues esta asesoría no es, no les voy a decir cómo se hace el trabajo completamente,
[09:59.560 --> 10:03.920]  porque recuerden que el profe pues es como quisquilloso pues con el tema de compartir
[10:03.920 --> 10:09.520]  códigos, y si les ve cierta similitud, pues se los anula. Entonces, la idea es solamente
[10:09.520 --> 10:14.360]  dejarles como una orientación del enunciado y ya más de ahí no puedo pasar. Ya pues,
[10:14.360 --> 10:19.240]  si ustedes necesitan alguna asesoría adicional con su código personal, ya pues Harrison les
[10:19.240 --> 10:24.400]  ayudará como con eso, pues él es el monitor de la materia, les hará reuniones aparte, y bueno.
[10:24.400 --> 10:30.400]  Entonces, ahora sí, muchachos, comencemos. Vamos a leer el enunciado, listo. Pues la idea es que lo
[10:30.400 --> 10:34.520]  tengan por eso ustedes por ahí a la mano, para que estén leyendo a la par conmigo, igual yo les voy a
[10:34.520 --> 10:44.840]  ir haciendo notas como para que no se pierdan, listo. Entonces, trabajo final. Bueno, entonces,
[10:44.840 --> 10:50.160]  dice, escribo un programa en C, obvio, pues hay que hacerlo en C, que realicen las traducciones
[10:50.160 --> 10:54.760]  de direcciones de memoria en un sistema que tiene un espacio virtual, listo. Entonces, empecemos
[10:54.760 --> 11:05.920]  por ahí. Entonces, es un espacio virtual de 32 bits. Entonces, ¿cuántos bits van a tener las
[11:05.920 --> 11:17.720]  direcciones de memoria? Si alguien se acuerda. Bueno, entonces, las direcciones de memoria van
[11:17.720 --> 11:22.200]  a tener pues 32 bits, ¿cierto? Pues es un espacio de direccionamiento virtual de 32 bits, pues las
[11:22.200 --> 11:26.640]  direcciones de memoria van a tener 32 bits, así de sencillo. Ahora, y me están diciendo que las
[11:26.640 --> 11:38.360]  páginas son de 4 kilobytes, bueno, 4 kilobytes, que eso es un kilobytes, es lo mismo que 1024
[11:38.360 --> 11:44.240]  bytes, ¿cierto? Pues son ciertas notaciones que hacen pues como en la cosa, pero uno se termina
[11:44.240 --> 11:49.680]  refiriendo pues a todo como kilobytes o kilobytes, pues los dos nombres son correctos. Entonces,
[11:49.680 --> 11:55.080]  me dicen que son páginas de 4 kilobytes, vamos a ponerlo 4kb, que no es así, listo. ¿Cuánto
[11:55.080 --> 12:03.720]  entonces son 4 kilobytes en bytes? A ver si se acuerdan. 4096. 4096 bytes, ¿sí o qué? Listo,
[12:03.720 --> 12:10.600]  súper. Entonces, empecemos por hallar eso. Como a mí me están diciendo que yo tengo que hacer unas
[12:10.600 --> 12:16.000]  traducciones, terminemos de leer el enunciado y después empezamos a sacar cálculos listos. Dice
[12:16.000 --> 12:21.240]  que el programa debe leer indefinidamente, listo, entonces el programa debe leer de manera indefinida,
[12:21.240 --> 12:36.880]  entonces leer de manera indefinida, listo. Leer de manera indefinida hasta que pulsen ese,
[12:39.080 --> 12:45.520]  hasta que escriban ese más bien, hasta que escriban... Sí, es cierto, pues yo me imagino que ustedes
[12:45.520 --> 12:50.520]  están en sistemas operativos, pues ya habrán visto fundamentos de programación, pues si
[12:50.520 --> 12:56.520]  no me dicen de manera indefinida, pues es un wild tracyoke, así de sencillo. Hasta que escriban
[12:56.520 --> 13:01.200]  ese, perdona que me equivoqué, no sé por qué me tosé ahí, hasta que escriban ese, listo, ese de
[13:01.200 --> 13:08.840]  minúscula. Vamos a la pequeñita, listo. Entonces, a mí me dicen que me están dando las direcciones
[13:08.840 --> 13:14.960]  en decimal, ¿cierto? Entonces, empecemos por ahí. Entonces, consideraciones.
[13:20.520 --> 13:29.200]  Entonces, lo primero es que el usuario, ¿cierto?, ingresará a las direcciones de memoria,
[13:39.680 --> 13:46.680]  en decimal, listo. Básicamente, ¿qué tenemos que hacer? Convertirlas a binario, extraer la página,
[13:46.680 --> 13:51.840]  extraer el desplazamiento y se acabó, ¿cierto? Así de sencillo. Entonces, me están diciendo que hay
[13:51.840 --> 14:01.880]  que mostrar, entonces, qué se tiene que imprimir. Uy, ¿de dónde salió ese cuadro? Que imprimimos,
[14:01.880 --> 14:07.720]  ¿cierto? ¿Ya ustedes verán de qué forma lo imprimen? Yo lo alcancé a ver del enunciado,
[14:07.720 --> 14:13.000]  el profesor no les puso ejemplos. Ah, sí, sí, les puse ejemplos. Ah, qué buenas. Ah, bueno, listo.
[14:13.920 --> 14:17.720]  Ah, no, pues claro, pues a mí también me han puesto ejemplos. Cool. Bueno, en todo caso,
[14:17.720 --> 14:21.960]  pues se pueden pasar los ejemplos para saber cómo imprimir, listo. Pues ya ustedes verán cómo lo
[14:21.960 --> 14:30.240]  quieren colocar. Listo. Entonces, ¿qué imprimimos entonces? Lo primero es el número de la página,
[14:30.240 --> 14:47.320]  desde el número de páginas en binario, en decimal y binario, perdón. Y en binario. O sea,
[14:47.320 --> 14:55.560]  que como el ejemplo que le signo acá al prove, por ejemplo, pueden colocar página 8, por ejemplo,
[14:55.560 --> 15:01.800]  y por acá más bajito poner página en binario. No sé, cualquier cosa en binario está tratando
[15:01.800 --> 15:06.240]  de 0, 0, 0. Pues si la página 8, pues ya ustedes saben cómo convertir un número de decimal a
[15:06.240 --> 15:12.240]  binario, pues usen la calculadora y listo. Pero pues acá, si el enunciado no ha cambiado mucho,
[15:12.240 --> 15:19.560]  según lo que veo, ustedes tienen que hacer una función que se les convierta eso a binario,
[15:19.560 --> 15:25.800]  muy probablemente. Y en efecto, sí. En efecto, sí les piden hacer eso. Bueno, lo que tenemos acá,
[15:25.800 --> 15:31.120]  entonces, primero tenemos que imprimir el número de la página en decimal y binario, listo. Dime.
[15:31.120 --> 15:40.600]  Una pregunta, a ver. Es que yo en esa parte estoy algo perdido porque, o sea, el enunciado dice que
[15:40.600 --> 15:51.760]  una entrada del TLB consiste pues en la dirección en decimal, la página, el desplazamiento y la
[15:51.760 --> 15:56.640]  página en binario, el desplazamiento en binario. Lo que pasa es que lo que yo he averiguado es que
[15:58.200 --> 16:03.600]  pues precisamente esos números que se guardan en decimal, pues se guardan en memoria, es
[16:03.600 --> 16:12.960]  precisamente como un binario. Y entonces ya la hora de, o sea, me parece redundante,
[16:12.960 --> 16:19.800]  usted guarda en la entrada del TLB, guardar el número en decimal y el otro guardarlo en
[16:19.800 --> 16:27.680]  algún tipo de binario. Lo raro es que, no sé, uno como que no puede guardar cosas, bueno,
[16:27.680 --> 16:31.480]  o por lo menos yo no he entendido cómo guardar cosas así en binario de forma,
[16:31.480 --> 16:39.920]  bueno, raw, no sé, como dice en inglés, sino que sería uno hacerlo con una, con un string,
[16:39.920 --> 16:47.800]  cierto, un string de decenas y unos. Sí. Lo que pasa es que el enunciado dice que son máximo 300
[16:47.800 --> 16:57.040]  bytes y serían, imagínese, 32 bytes, que sería pues un string de esos multiplicado por las cinco
[16:57.040 --> 17:06.280]  entradas, eso se repasa de los 300. Entonces yo no sé si el profe quiere que nosotros guardemos
[17:06.280 --> 17:12.760]  eso ahí en binario de alguna forma o simplemente cuando vamos a imprimir, que si imprimamos del
[17:12.760 --> 17:18.400]  decimal, obviamente fácilmente imprimimos el decimal. Y como usted dice, con una función
[17:18.400 --> 17:24.120]  lo pensamos a binario. O si eso se guarda precisamente en memoria, eso está ahí como raro.
[17:25.080 --> 17:29.920]  Listo, entiendo. Esa pregunta está muy buena porque es la misma pregunta que yo me hice cuando
[17:29.920 --> 17:35.920]  estaba haciendo el trabajo. ¿Qué me dijeron a mí, muchachos? Guarden todo. ¿Cómo así? O sea,
[17:35.920 --> 17:41.800]  ustedes pueden, como él me dijo, ustedes pueden calcular la página y el desplazamiento a partir
[17:41.800 --> 17:45.480]  del decimal con unas divisiones del tamaño de la página y un módulo, que yo se los mostré en
[17:45.480 --> 17:50.760]  talleres, ya lo vamos a hacer tranquilos. Y simplemente llegar a imprimir esa cálculo,
[17:50.760 --> 17:58.640]  pues es más fácil. ¿Qué pasa? En el TLB ustedes tienen cinco entradas, ¿cierto? Pues acuérdense
[17:58.640 --> 18:03.360]  que esto va a ser como un... Recuerden que no pueden usar a raíz. Estos literalmente son
[18:03.360 --> 18:07.880]  posiciones consecutivas de memoria. Vamos a suponer que estos son cinco cuadritos de chocolatina y
[18:07.880 --> 18:13.800]  cada cuadrito de chocolatina pues mide una cantidad de bytes, ¿cierto? ¿Qué es lo que tenemos que
[18:13.800 --> 18:21.760]  guardar? Entonces, ahí sí vamos para eso. Porque, ah, bueno, eso... O sea, primero les quiero mostrar
[18:21.760 --> 18:26.640]  qué tenemos que imprimir, como para que nos desviemos de eso y ya te muestro pues qué es lo
[18:26.640 --> 18:32.760]  que hay que hacer list. Bueno, entonces, ¿qué imprimimos? Pues el número de la página en
[18:32.760 --> 18:40.600]  decimal y en binario. Primero eso. Luego el desplazamiento. El desplazamiento, ¿cierto? Pues
[18:40.600 --> 18:47.440]  eso lo van a hallar a partir de la dirección. En decimal y en binario también, ¿cierto? El
[18:47.440 --> 18:53.080]  desplazamiento, ¿dónde? Pues dentro de la página, ¿cierto? Pues eso es de toda la vida. En decimal y
[18:53.080 --> 19:00.720]  en binario. Listo. Y ahora, pues ustedes ven que hay un poco de cosas que hay que guardar. Ya les
[19:00.720 --> 19:04.880]  voy a mostrar entonces qué es lo que vamos a guardar y cómo podemos interpretar eso, listo.
[19:05.880 --> 19:11.040]  Ah, bueno, el tiempo en segundos, que ya les voy a mostrar eso también cómo se hace.
[19:13.360 --> 19:23.240]  El tiempo en segundos, listo. El tiempo en segundos que tomó hacer eso, que tomó hacer los cálculos,
[19:23.240 --> 19:35.360]  hacer todo, mejor dicho. Listo. Y lo otro es que, ah, bueno, sí, si es un hit o un miss,
[19:35.360 --> 19:43.720]  listo. Entonces, si es un TLB hit o un TLB miss, si ustedes lo recuerdan, esto es simplemente ver
[19:43.720 --> 19:53.640]  si está o no está, ¿cierto? Listo. Y listo. Acá me dicen, entonces, más consideración, entonces.
[19:57.720 --> 20:05.120]  Las otras, entonces lo otro es que, a ver, a mí me dicen, para simular el TLB debe usar memoria en
[20:05.120 --> 20:10.880]  el segmento hip obligatorio. ¿Cómo así que el segmento hip? Si ustedes se acuerdan de talleres
[20:10.880 --> 20:17.000]  anteriores que han asistido, recuerden que uno, como reserva memoria en el hip, básicamente,
[20:17.000 --> 20:23.240]  con esta funcióncita llama malloc. ¿Qué nos pide? Mínimamente, bueno, en general,
[20:23.240 --> 20:27.920]  ¿qué nos pide un malloc? Pues, básicamente, el tamaño en bikes que yo necesito reservar, ya,
[20:27.920 --> 20:37.600]  pare de contar. Ahora, a mí me están diciendo, entonces, hay que usar malloc, ¿cierto? Empezando
[20:37.600 --> 20:51.560]  por ahí. Bueno, y lo otro es que, listo, ya, ya acabó el enunciado tal cual. Ahora,
[20:53.080 --> 20:58.840]  ¿qué cosas hay que hacer? Lo que me está diciendo acá Samuel. Nosotros tenemos un espacio máximo
[20:58.840 --> 21:08.480]  de 300 bytes. Es decir, en esos 300 bytes tenemos que guardar las 5 entradas.
[21:12.000 --> 21:18.800]  Ahora, si nosotros tenemos 5 entradas que deben ser, bueno, ya les voy a mostrar cuánto tiene cada
[21:18.800 --> 21:22.920]  entrada, es que creo que me estoy adelantando mucho a veces. Entonces, cada entrada debe tener,
[21:22.920 --> 21:32.160]  primero, dice consta mínimamente, ¿cierto? Entonces, vamos a guardar eso. Entonces, dirección de
[21:32.160 --> 21:51.640]  memoria en decimal. En decimal, listo. ¿Qué más hay que guardar en el TLB? El número, ¿qué? El
[21:51.640 --> 22:03.560]  número de la página en decimal. Entonces, el número de página en decimal. ¿Qué más hay que guardar?
[22:06.160 --> 22:16.480]  El desplazamiento en decimal. Desplazamiento en decimal, listo. Y también me piden guardar el
[22:16.480 --> 22:21.320]  número de página en binario y el desplazamiento en binario. O sea, básicamente, los dos anteriores,
[22:21.320 --> 22:31.400]  pero en binario, listo. Entonces, página en binario y desplazamiento en binario. Ahora,
[22:31.400 --> 22:37.240]  ¿ustedes cómo van a hacer esas impresiones? Listo. Básicamente, ustedes, como están trabajando con un
[22:37.240 --> 22:45.720]  TLB, lo que tienen que hacer es coger dentro de cada entrada, ¿cierto? Y irse desplazando
[22:45.720 --> 22:51.000]  x cantidad de bytes según ustedes definan sus entradas, ¿cierto? Ya les voy a mostrar. ¿Qué
[22:51.000 --> 22:56.800]  tiene que tener la entrada? Esto es de aquí, ¿cierto? Ahora, ustedes deben decidir qué tipos
[22:56.800 --> 23:02.000]  de variables van a usar para que derrindan los 300 bytes. Entonces, si son cinco entradas y el
[23:02.000 --> 23:07.080]  tamaño máximo son 300 bytes, entonces, ¿cuántos bytes máximo puede tener cada entrada? 300 sobre
[23:07.560 --> 23:16.200]  cinco, ¿sí o qué? ¿Y eso nos debería dar cuánto? Todas 60. 60 bytes. Listo. Entonces,
[23:16.200 --> 23:24.320]  nosotros tenemos que hacer rendir 60 bytes para guardar todo esto, ¿sí? Ahora, es verdad lo que
[23:24.320 --> 23:30.040]  dice Samuel. Yo la verdad desconozco cómo guardar binarios, tal cual. Pues es que un binario es una
[23:30.040 --> 23:36.080]  sección, una regla de números. Entonces, yo, por ejemplo, yo ¿cómo hice el trabajo? Pues nada,
[23:36.080 --> 23:44.480]  lo que era binario mandélo a char. Un arreglo de chars. Ya, eso es todo. Ahora, ustedes pueden
[23:44.480 --> 23:49.960]  usar las variables que quieran. ¿Yo qué recomendación les voy a dar? Para, recuerden que la dirección de
[23:49.960 --> 23:56.760]  memoria en decimal es un número, ¿cierto? Ahora, ¿cuál es la dirección máxima en decimal que
[23:56.760 --> 24:02.360]  ustedes pueden tener en este sistema si sus páginas son de 4 kilobytes y tienen un sistema
[24:02.360 --> 24:08.560]  de 32 bits? Bueno, realmente las páginas no me interesan tanto. ¿Cuánto pueden direccionar
[24:08.560 --> 24:16.720]  ustedes en 32 bits? ¿Cuántos bytes? ¿Sí se acuerdan que todo el espacio de dirección
[24:16.720 --> 24:24.040]  ambiental era 2 a la M, es cierto? ¿Y que M era quién? El tamaño total. El tamaño total. Listo.
[24:24.040 --> 24:28.240]  Entonces, ¿cuál es M? Si a mí me dicen que la arquitectura son 32 bits, entonces ¿cuánto
[24:28.240 --> 24:40.400]  tengo que direccionar yo en virtual? Pues 2 a la 32, ¿sí o qué? Y 2 a la 32, si mal no estoy,
[24:40.400 --> 24:49.200]  vamos a ver si me acuerdo de cuánto es esto. 4294.200. Bueno, ya, no me acuerdo la verdad.
[24:49.360 --> 24:55.640]  Vamos a calcularlo. A ver, si se puede sacar la calculadora normal, están escribiendo 2 a la 32.
[24:58.800 --> 25:11.320]  Y eso me da, bueno, no está tan alejado, 4294.967.296. Pero recuerden que los bytes van del cero
[25:11.320 --> 25:16.880]  en adelante, entonces se le tiene que restar uno de este número. Era 296, pues ¿hasta dónde el
[25:16.880 --> 25:24.400]  máximo? A 295. Ya, eso es todo. Listo. Bueno, entonces eso por ahí, entonces ustedes tienen que,
[25:24.400 --> 25:32.600]  ustedes pueden direccionar todo esto. Ahora, como ustedes se acuerdan, si yo tengo entonces 32 bits,
[25:32.600 --> 25:36.760]  pues mis enteros también son de 32 bits, entonces yo puedo guardar todo esto en un entero, ¿sí o qué?
[25:38.840 --> 25:42.920]  Ya, les guardemos ese número en un entero, pues esa es la dirección. Esta es la dirección máxima
[25:42.920 --> 25:47.000]  que me pueden dar en décima del ojo. Tengan en cuenta eso, porque ustedes tienen que también,
[25:47.000 --> 25:52.920]  eso es lo que vamos a ver enseguida, escribir page fault cuando se salgan de este espacio o cuando
[25:52.920 --> 25:56.800]  se vayan para atrás, ¿cierto? O sea, si ustedes se van como direcciones negativas, pues sería chévere
[25:56.800 --> 26:00.640]  que dijeran que es un page fault, porque eso no es una dirección de memoria. Si se exceden de este
[26:00.640 --> 26:05.960]  tamaño, eso también es un page fault. Listo. ¿Qué era page fault? Pues básicamente, si yo tengo todo
[26:05.960 --> 26:10.080]  ese espacio de memoria, llego y apunto por aquí, pues miren que eso nada que ver, ¿cierto? Pues estoy
[26:10.080 --> 26:14.640]  cayendo por fuera de la memoria. Entonces, pues ahí, X, ¿sí o qué? Entonces decimos que es page
[26:14.640 --> 26:22.080]  fault. Vamos a ver esto por acá, porque esto me sirve para... Listo. Entonces, si son puros números
[26:22.080 --> 26:25.680]  en decimal, pues los números en decimal son los que nosotros tenemos. Y a mí todo este número de acá
[26:25.680 --> 26:31.520]  me cabe en lo que yo necesito. Entonces, pues básicamente, pues yo puedo guardar todo esto en
[26:31.520 --> 26:35.080]  un entero. En un entero de 32 bits, ¿sí o qué?
[26:35.080 --> 26:44.720]  Bueno, en 32 bien bajote, perdón. Ahora, ustedes pueden usar el que quieran, ¿cierto? Pero pues yo
[26:44.720 --> 26:49.840]  les recomendaría hacer esto. ¿En qué podemos guardar la página? También lo mismo, un entero
[26:49.840 --> 26:55.240]  de 32 bits. O bueno, como la arquitectura de 32 bits, no es necesario. Aunque, si ustedes están
[26:55.240 --> 27:01.680]  trabajando en un editor como IntelliJ, ¿cómo es que se llama eso? Eso es Silaion, EPA. Si están
[27:01.680 --> 27:06.680]  trabajando en una IDE JetBrains, ustedes tienen que saber que, pues yo me imagino que todos sus
[27:06.680 --> 27:11.120]  computadores deben ser de 64 bits. Pues no conozco la primera persona que tengo de 32 hoy en día.
[27:11.960 --> 27:17.520]  Obviamente, pues si ustedes tienen una arquitectura de 64, pues entonces... Yo, por ejemplo, lo que
[27:17.520 --> 27:21.080]  hice en el trabajo, pues básicamente fue a cortar todos los enteros a 32 bits para no
[27:21.080 --> 27:24.880]  tenerme que estar metiendo y saliéndome de la máquina virtual. Cada día hacer un cambio, ¿sí?
[27:24.880 --> 27:30.440]  Entonces, básicamente, pues lo pueden acortar o lo pueden poner solamente in, ¿cierto? Pues
[27:30.440 --> 27:35.720]  si ustedes están trabajando en su máquina, pues bien, tranquilos, ¿sí? Listo. Pues el
[27:35.720 --> 27:39.160]  desplazamiento también es un número en décima, lo mismo, lo pueden guardar en un entero tal cual.
[27:39.160 --> 27:42.120]  Entonces, si son enteros de 32 bits, ¿cuánto pesan en bytes?
[27:49.160 --> 27:57.080]  4. 4. Sí, ok, 4 bytes. Entonces, ya 4. Ese también pesa 4 y este también pesa 4. Miren que ya
[27:57.080 --> 28:02.040]  llevamos tres de las cinco cosas que tenemos que guardar y ya llevamos 12 bytes gastados, ¿cierto?
[28:02.920 --> 28:09.120]  Listo. Ahora viene lo potente, lo de los binarios. Como les estaba diciendo, ustedes pueden guardar
[28:09.120 --> 28:15.400]  tranquilamente un char array con la cantidad que necesitan, pues guardar de chars aquí y pues el
[28:15.400 --> 28:19.520]  número en binario puede ser como cero, uno, cero, pa, pa, pa, pa, pa. Es una cadena de puros ceros y
[28:19.520 --> 28:27.480]  unos. Ustedes se lo pueden hacer así. Así fue como yo lo hice y ya les voy a mostrar. Realmente,
[28:30.720 --> 28:39.660]  bueno, vamos a ver. Listo. Entonces, ustedes saben que las páginas y el desplazamiento se tienen
[28:39.660 --> 28:46.360]  que hallar de un cálculo. Ahora, yo como sé cuántos bits necesito para direccionar la página
[28:46.360 --> 28:52.280]  y el desplazamiento. Entonces, vamos a recordar que nosotros teníamos acá todo este arreglo,
[28:52.280 --> 28:57.720]  que media m, ¿cierto? Pues ya no es importante que se acuerden de esto porque pues ya no se los,
[28:57.720 --> 29:01.760]  bueno, de pronto se los van a evaluar muchachos en la sustentación, ¿cierto? En la sustentación
[29:01.760 --> 29:07.400]  de pronto los ponen a desplazarse cosas de bits y eso. Entonces, si ustedes hacen el trabajo a
[29:07.400 --> 29:13.520]  conciencia, créanme que les va a ir muy bien. Entonces, todo este m era, pues m era 32, ¿cierto?
[29:13.520 --> 29:20.360]  Pues entonces, y yo necesitaba un n y acá un m menos n. Entonces, básicamente, pues yo tenía que
[29:20.360 --> 29:24.640]  dos a la n, tenía que ser el tamaño de la página. ¿Cuánto era que habíamos dicho que harían las
[29:24.640 --> 29:32.640]  páginas? 4 kilobytes o 4096 bytes, ¿cierto? Entonces, esto es un logaritmo en base 2 de 4096,
[29:32.640 --> 29:38.440]  tal que me dé un n, que yo le vea 2 y me dé, pues básicamente, cuántos bits necesito para la página.
[29:38.440 --> 29:48.120]  Así de sencillo. A ver, a ganar y lo, ¿cómo es? ¿Cómo es que yo decía? 12. Entonces, ¿cuántos
[29:48.120 --> 29:58.200]  bits necesitas para la página? 12, ¿sí o qué? Entonces, n es 12. Entonces, m menos n, ¿cuánto tiene que dar?
[29:58.200 --> 30:10.880]  32 menos 12, 20, ¿sí o qué? Ya listo. Ya hallamos cuántos bits necesitamos para esto y cuántos bits
[30:10.880 --> 30:15.920]  necesitamos para esto. Como lo estamos haciendo, entonces, básicamente, si tenemos que guardar un
[30:15.920 --> 30:20.560]  arreglo de toda esta cantidad de caracteres y toda esta cantidad de caracteres, entonces listo. Pues
[30:20.560 --> 30:27.320]  nada, hagamos unos charts que me guarden esa cantidad de caracteres. Ahora, pues nada, yo,
[30:27.320 --> 30:31.480]  por ejemplo, la página en binario, entonces, si la página se gasta 20, entonces un chart de 20.
[30:32.680 --> 30:37.600]  Y si el desplazamiento se me gasta 12, pues un chart de 12. Listo. Yo les pregunto a ustedes,
[30:37.600 --> 30:46.440]  ¿esto es correcto? ¿Ustedes creen que ese está perfecto así como lo tengo?
[30:49.040 --> 30:50.840]  O a alguien que diga que me equivoqué.
[30:50.840 --> 30:58.880]  De pronto hay que reservar un espacio más para el carácter nulo.
[30:58.880 --> 31:05.000]  Exacto, muy bien. Eso, excelente. Tienes que reservar uno más para el carácter nulo. ¿Por qué?
[31:05.000 --> 31:12.560]  Porque en C, si ustedes lo recuerdan, nosotros tenemos las cadenas y la consola imprime,
[31:12.560 --> 31:16.320]  imprime, imprime hasta que se encuentra con algo llamado el carácter nulo, que básicamente es
[31:16.320 --> 31:23.520]  backslash cero y ya. Este chart de aquí se llama el carácter nulo y básicamente marca el final de
[31:23.520 --> 31:30.800]  una cadena. Entonces, como nos dijo acá Samuel, cierto, pues tenemos que guardar uno más. Listo,
[31:30.800 --> 31:38.680]  pues acá hacemos la modificación. Entonces no es un chart de 20, sino de 21. Y acá es un chart de 13.
[31:39.680 --> 31:46.800]  Listo, si ustedes se acuerdan en un taller, yo les dije cuánto pesaba un chart, ¿cuánto pesa un chart?
[31:53.280 --> 31:58.600]  Un byte. Un byte, listo. ¿Y cuántos charts tenemos en la página del desplazamiento?
[32:03.880 --> 32:07.400]  21 y 13. 21 y 13.
[32:08.840 --> 32:11.040]  Y si nosotros sumamos todo esto, ¿cuánto nos debería dar?
[32:13.880 --> 32:22.200]  4 más 4 más 4, 12 más 13, 25 más 21, 46.
[32:24.320 --> 32:31.760]  46 menor que 60, ¿sí o qué? Ya. Entonces, en efecto, pues miren que ya tenemos lo que nos piden
[32:31.760 --> 32:37.560]  guardar dentro de cada entrada del TLV sin excedernos del espacio. Ahora, esta es mi recomendación
[32:37.560 --> 32:41.880]  de cómo hacerlo. Ustedes lo pueden hacer con los tipos de variables que quieran. Si ustedes
[32:41.880 --> 32:45.440]  encuentran la manera de guardar decimales de alguna manera, un tipo de variable que la verdad
[32:45.440 --> 32:49.880]  desconozco, bienvenido sea. No sé si el profe les ponga restricción con eso. Igual, de pronto el
[32:49.880 --> 32:56.960]  anunciado lo irá. Y bueno, entonces miren que ahí, pues, por ejemplo, en este caso, pues como yo se
[32:56.960 --> 33:05.400]  los estoy proponiendo, pues les daría 46 bytes en total de cada una de las cositas que ustedes
[33:05.400 --> 33:13.960]  van a guardar en el TLV, ¿cierto? Ya, pues miren que ahí goleamos. Entonces, yo tengo que reservar
[33:13.960 --> 33:21.360]  con un malloc el tamaño de 5 entradas, entonces 5 por y no se pueden definir una constante,
[33:21.360 --> 33:27.480]  por ejemplo. Yo cómo le recomendaría, definan todo esto arriba del código, ¿cierto? Después
[33:27.480 --> 33:34.600]  de las importaciones de librerías con el hashtag define, ¿cierto? Y le ponen el nombre de la constante
[33:34.600 --> 33:40.120]  como ustedes quieran, no sé, dirección decimal, algo así, ¿cierto? Ya ustedes verán. Y le ponen
[33:40.120 --> 33:45.480]  que, por ejemplo, acá, pues, como nos dio acá en el ejemplo, 4 bytes. Y entonces definen todas
[33:45.480 --> 33:51.440]  esas constantes y más abajito, pues, lo que llegan y dicen como, no sé, part o partición o como le
[33:51.440 --> 33:56.240]  quieran poner, es igual a la suma de todas esas constantes. Como las definimos aquí arribita,
[33:56.240 --> 34:01.240]  entonces es tan fácil como llegar y coger este nombre y decir, ah, sí, dirección en tatatá,
[34:01.240 --> 34:07.080]  más el otro que le haya pues acá, no sé, hello, binario, alguna cosa así, y pues lo
[34:07.080 --> 34:12.520]  suma aquí, ¿cierto? Eso me haría dar en total, entonces, 46. ¿Por qué lo hacemos de esa manera y
[34:12.520 --> 34:16.520]  no simplemente decir que particiones 46? No sé, para que quede más bonito el código. ¿Listo?
[34:17.560 --> 34:20.320]  Bueno, ¿hay alguna duda con eso por ahora o todo bien?
[34:20.320 --> 34:42.520]  Listo. Samuel, ¿te quedó claro entonces? Bueno, vamos a suponer que sí. Listo. Entonces,
[34:42.520 --> 34:48.720]  eso por ese ladito. Ahora vamos a hablar de algo superimportante, que es la política de
[34:48.720 --> 34:58.200]  reemplazo. Entonces, ¿la política de reemplazo qué nos dice? Dice, ¿saben, yo acabo de escribir eso?
[35:00.080 --> 35:06.840]  Me está diciendo, la política de reemplazo en el TLV estará basada en la política MRU. Listo,
[35:06.840 --> 35:12.080]  ¿cómo así que hay que reemplazar? Ay, ¿cómo así? Listo, te lo voy a mostrar. Ustedes,
[35:12.080 --> 35:17.880]  como lo tienen aquí, recuerden nuestro ejemplo de los cinco pasitos de chocolate, ¿cierto?
[35:18.360 --> 35:23.400]  Este es el TLV. Cinco pasitos de chocolate, un pedacito de chocolate. Pues ustedes pueden
[35:23.400 --> 35:30.600]  guardar esto que tenemos acá, ¿cierto? Listo. Cuando el usuario hace una consulta, ¿cierto?
[35:30.600 --> 35:37.360]  Que básicamente es ingresar la dirección de memoria en decimal. Entonces, ustedes van a hacer
[35:37.360 --> 35:44.520]  todos los cálculos necesarios para obtener eso y los vamos a guardar aquí. Listo. Vamos a suponer
[35:44.520 --> 35:48.200]  que esta fue la primera que se consultó, que esta fue la segunda, que esta fue la tercera,
[35:48.200 --> 35:54.000]  esta es la cuarta y esta es la quinta. Listo. Miren que en un TLV ustedes guardan hasta que se
[35:54.000 --> 35:59.280]  les llene la memoria. Ya se les llenó la memoria. Pues miren que ya nos gastamos las cinco cuadritos
[35:59.280 --> 36:05.840]  de chocolate. Ahora, yo, siendo el usuario, pues no me voy a quedar en cinco consultas,
[36:05.840 --> 36:09.720]  yo voy a hacer más. Acuérdense que les voy a hacer infinitas consultas hasta que opriman
[36:09.720 --> 36:13.720]  eso o hasta que se acabe el mundo. Literalmente, hasta que desconecten el computador y se reinicie
[36:13.720 --> 36:20.920]  el programa. No sé, alguna cosa bien loca. Entonces, si ustedes recuerdan, nosotros teníamos
[36:20.920 --> 36:28.440]  ciertas formas de hacer estos reemplazos, ¿cierto? Listo. Básicamente, entonces,
[36:28.440 --> 36:32.720]  ¿cómo lo hacemos? No están diciendo. La política estará basada en MRU.
[36:34.960 --> 36:42.400]  Si ustedes recuerdan, ALRU, Least Recently Used, entonces este es el análogo, pues entonces es
[36:42.400 --> 36:49.760]  el Most Recently Used. En español, en español, entonces en español es el más reciente usado.
[36:49.760 --> 36:54.840]  Entonces, como acá no estamos hablando de recursos, sino que estamos hablando literalmente de cosas
[36:54.840 --> 36:58.160]  que estamos guardando acá. Entonces, ¿cuál fue el último que yo metí?
[37:04.560 --> 37:10.720]  ¿Cuál fue la última entrada que yo puse acá? El 5. El 5, sí o qué. Entonces, ¿cuál vas a reemplazar?
[37:11.480 --> 37:18.480]  Ese, sí o qué. Listo, súper bien. Entonces, vos, por ejemplo, ya tenés acá la query 6.
[37:21.120 --> 37:26.600]  Ahora, supone que volviste a hacer la consulta del 3. ¿Eso es un miss o un hit?
[37:26.600 --> 37:32.960]  Un hit. Un hit, sí o qué, perfecto. Entonces, como estamos haciendo Most Recently Used, entonces,
[37:32.960 --> 37:37.400]  ¿cómo te va a quedar esa lista? Pues esa filita. Esto es solamente ejemplificado, listo.
[37:37.400 --> 37:43.480]  ¿Cómo te va a quedar eso? Si accedimos atrás.
[37:46.360 --> 37:48.240]  O sea, el orden de los números, ¿cómo te quedaría?
[37:50.720 --> 37:54.760]  Se tira para el último, ¿cierto? Como 1, 2, 4, 6, 3.
[37:56.600 --> 38:04.280]  Bueno, es que a ver, yo realmente lo haría así tirándolo para el último, porque recuerden que
[38:04.280 --> 38:10.480]  las posiciones en esas listas suelen significar, por ejemplo, cuando a mí me queda el de más adelante,
[38:10.480 --> 38:16.520]  entonces, eso quiere decir que es el que menos ha usado. Pues, análogamente, si yo dejo al último,
[38:16.520 --> 38:22.040]  pues el último sería el que más reciente he usado, ¿cierto? Pues, eso sería el ejemplo análogo.
[38:22.040 --> 38:29.600]  Déjenme, yo voy acá rapidito. El profile no les explicó casi nada de Most Recently Used.
[38:29.760 --> 38:38.240]  Solamente les digo como 1 en los ya. Ah, no, listo. Entonces, sí, creo que no sería como tan camisa de fuerza.
[38:41.600 --> 38:47.800]  Ah, no, sí, ¿sabes qué? Sí, aquí está, mire. Últimas referencias expulsadas.
[38:47.800 --> 38:53.960]  Ah, ya. Sí, sí, sí. Páginas accedidas en orden. Sí, sí, es la última. Es la última en efecto.
[38:53.960 --> 38:58.720]  Listo. Entonces, súper bien. Entonces, vamos súper bien. Entonces, me diste que lo pasas para el final, ¿cierto?
[38:59.760 --> 39:04.320]  Entonces, ¿te quedaba la cola como? Si teníamos 3, 4 y 6, ¿cómo lo reorganizamos para que nos quedé así?
[39:08.440 --> 39:16.000]  1, 2, 4, 6, 3. 1, 2, 4, 6, 3. Listo. Entonces, en el caso en el que yo llegue y hago otra consulta,
[39:16.000 --> 39:22.400]  imagínense la consulta 7. Eso es un miss, ¿cierto? Si yo intento consultarlo, esto acá no está.
[39:22.400 --> 39:27.560]  ¿Qué tengo que hacer? Pues, reemplazar. ¿Por quién lo voy a reemplazar?
[39:30.440 --> 39:36.160]  Por el 3. Por el 3, sí, ok. Pues ya, pues si están en el último, pues nada, métalo ahí y listo, chao.
[39:36.160 --> 39:42.280]  Entonces, miren que así se va yendo MRU, ¿cierto? El que a usted le va quedando de último es justamente
[39:42.280 --> 39:52.480]  el que ustedes pues tienen que reemplazar, ¿cierto? Ahora, hay dos maneras de hacerlo. Una es que
[39:52.480 --> 39:58.840]  literalmente cada que hagan, o sea, si ustedes se acuerdan, nosotros cuando llegamos a hacer algo
[39:58.840 --> 40:02.360]  por aquí, pues obviamente necesitamos pasarlo para atrás del todo, pues para decir que es el que más
[40:02.360 --> 40:11.040]  reciente se usó. ¿Cómo lo pueden hacer? Yo les recomiendo que, a ver, le pueden preguntar a HGPT
[40:11.040 --> 40:16.600]  o buscar documentación como a ustedes les guste, ¿cierto? Hay ciertos métodos que se llaman memcopy,
[40:16.600 --> 40:22.520]  memcpy, que si a ustedes le pasan unos ciertos parámetros, que después están la documentación,
[40:22.520 --> 40:28.800]  me imagino, ustedes pueden copiar partes de la memoria y pasarlas acá a hacer esto, ¿cierto?
[40:28.960 --> 40:35.280]  TAM, TAM, TAM. Esa es una manera de hacerlo, ¿cierto? Pues si literalmente yo tengo que mover las entradas
[40:35.280 --> 40:39.240]  del TV, pues para no complicarme la vida, es decir que la que siempre reemplaza es la última,
[40:39.240 --> 40:49.160]  entonces, bueno. Ahora, ¿qué pueden hacer también? Bueno, y si alguien le pregunta a Harrison,
[40:49.160 --> 40:55.480]  porque no creo que estaría mal, ustedes pueden, es que no estoy seguro, porque es que el profe le
[40:55.480 --> 40:59.880]  dice que no pueden usar ARRAYS ni nada de eso, indicadores. O sea, todo lo tienen que hacer con
[40:59.880 --> 41:09.680]  apuntadores. Ah, bueno, ustedes tienen asesoría con él mañana. Yo les voy a decir esto y enseguida,
[41:09.680 --> 41:13.480]  igual, pues yo estoy con Harrison en un trabajo, entonces enseguida le pregunto, si ustedes pueden
[41:13.480 --> 41:17.800]  usar un arreglo para gestionar quiénes son los que están entrando aquí, aunque no creo.
[41:20.760 --> 41:24.480]  Es que no le sabría decir, porque como yo no he sido el monitor, no sé qué cosa se puede, o sea,
[41:24.480 --> 41:31.400]  según el enunciado, pues sé que se puede hacer, pues cuando ustedes tienen que mostrar también
[41:31.400 --> 41:38.880]  en la impresión la política de reemplazo. O sea, ustedes tienen que, aparte de lo que tienen que
[41:38.880 --> 41:45.600]  imprimir aquí, también tienen que imprimir qué página reemplazar, pues qué dirección de memoria
[41:45.600 --> 41:51.840]  reemplazar, entonces cuál reemplazar. Si ustedes recuerdan, pues cada una de esas direcciones,
[41:51.840 --> 41:58.800]  pues va a ser 0, x, no sé qué, un número en hexadecimal. Entonces ustedes tienen que decir la
[41:58.800 --> 42:04.640]  dirección base, básicamente donde comienza pues el pedacito de chocolate que ustedes reemplazan,
[42:04.640 --> 42:12.160]  ¿cierto? Si ustedes hacen eso de pasar todos, literalmente de hacerle, de reorganizar la memoria
[42:12.160 --> 42:16.720]  de modo que siempre les quede el último que acceden aquí atrás, ¿cierto? Y pues pasan,
[42:16.720 --> 42:22.600]  por ejemplo, no sé, como lo que hicimos acá, pues pasamos el que estaba el 6, que era el último,
[42:22.600 --> 42:26.880]  para acá, el 4 que estaba aquí, lo pasamos para acá, y entonces nos queda así. Ustedes pueden
[42:26.880 --> 42:31.120]  mover las entradas del TLB para hacer eso, ¿cierto? Pues nada más es tan fácil como llegar y copiar
[42:31.120 --> 42:40.520]  una porción de la memoria y pasarla a otra. Pues esta fue la forma en la que yo lo hice. Ahora,
[42:40.520 --> 42:44.400]  no me gustaría pues darles esa única manera, porque si todos se quedan con esa forma de
[42:44.480 --> 42:50.000]  hacerlo, pues es que no creo que igual hayan muchas formas de hacerlo, pero si viene un montón de
[42:50.000 --> 42:56.480]  gente con esa forma de hacerlo, pues obviamente va a ser raro, ¿sí o qué? Entonces, básicamente,
[42:56.480 --> 43:02.360]  pues podrían usar esas dos maneras. Pues una es mover las direcciones de memoria y la otra es
[43:02.360 --> 43:07.440]  tener algo, básicamente, que les esté diciendo cuál fue la última y guardar la dirección de
[43:07.440 --> 43:16.400]  memoria de ese, aunque eso me parece más complicado incluso. ¿Saben qué? Pues las dos no les quisiera
[43:16.400 --> 43:21.760]  como decir algo pues erróneo. Entonces, si pueden asistir mañana a la asesoría con Harrison y
[43:21.760 --> 43:29.480]  preguntarle acerca de cómo pueden hacer esto del MRU y le proponen pues esto que yo les dije,
[43:29.480 --> 43:36.520]  pues ya pues él es el monitor, él es el que les va a calificar, pues ahí sí ya se me salen las
[43:36.520 --> 43:43.240]  manos, ¿sí o qué? Pero pues espero que hayan entendido pues cómo es MRU, ¿cierto? Porque
[43:43.240 --> 43:49.720]  básicamente pues toca hacer esos reemplazos pues porque para imprimir, pues yo tengo que literalmente
[43:49.720 --> 43:55.880]  ir al TV y extraer cada una de estas cosas, ¿cierto? Ustedes que van a imprimir literalmente llegan y
[43:55.880 --> 44:03.840]  ponen a imprimar lo que está en la dirección, ta ta ta ta ta, imprima lo que está en la dirección,
[44:04.160 --> 44:08.160]  imprima lo que está en la dirección, ta ta ta, así tiene que imprimir todo. ¿Para qué? Para mostrar
[44:08.160 --> 44:12.720]  básicamente que ustedes guardaron eso en el TV, ¿cierto? Es una forma mucha de demostrar.
[44:14.640 --> 44:22.360]  Listo, ah bueno lo otro muchachos es que cuando no haya reemplazos, si se acuerdan que había una
[44:22.360 --> 44:29.760]  forma, o sea que yo tenía los cinco cuadritos acá, ¿cierto? Y si yo hacía la uno, dos, tres,
[44:29.760 --> 44:34.520]  cuatro, cinco, miren que ustedes no están reemplazando a nadie ahí, entonces ¿cuál va a
[44:34.520 --> 44:38.720]  ser su política de reemplazo? Pues ninguna porque no tienen que reemplazar a nadie, entonces en esto
[44:38.720 --> 44:47.000]  de cuál reemplace, cuál reemplaza, pues va a poner 0x0, listo. Entonces ponemos 0x0 en caso de que no
[44:47.000 --> 44:53.040]  tengamos que reemplazar a nadie. ¿En qué caso se puede dar eso? En un hit o cuando la memoria esté
[44:53.040 --> 44:57.240]  así pues como les acabo de mostrar, pues se da un espacio vacío, pues yo la meto, yo lo meto, yo lo
[44:57.800 --> 45:01.320]  meto, o si accedo a algo que ya está, ¿cierto? Pues ahí no estoy reemplazando a nadie, ¿cierto?
[45:02.320 --> 45:09.360]  Pues eso es un 0x0 también. Entonces, ¿qué no se puede usar?
[45:17.200 --> 45:22.600]  Porque yo me imagino que ustedes piensan, ah no, pues más fácil hago eso en una lista y los accedo
[45:22.600 --> 45:27.680]  con el índice 0, con el índice 1, con el índice 12, sucesivamente, pues más fácil no, pues eso no
[45:27.680 --> 45:32.920]  se puede hacer. ¿Por qué? Porque el profe quiere que sea así, pues justamente pues ahí no estudiaría
[45:32.920 --> 45:36.560]  nada de memoria, pues solamente sería lo de todos los lenguajes, acceder a posiciones de
[45:39.000 --> 45:44.160]  un array con índices y eso no se puede hacer, listo. Entonces para que lo tengan muy en cuenta.
[45:44.160 --> 45:47.200]  Entonces, ¿no se puede usar arreglos?
[45:53.600 --> 45:59.520]  De ninguna dimensión, según dice el profe, eso, por eso es que les estoy diciendo muchachos que yo
[45:59.520 --> 46:05.000]  no sé si ustedes pueden usar al menos un arreglo como para saber cuál es el que están, cuál es el
[46:05.000 --> 46:11.960]  que están referenciando más reciente. Larda, larda, larda, en este momento no sé, no sé qué
[46:11.960 --> 46:17.080]  decirles con respecto a esto. Entonces, pues los invito pues a que le pregunten mañana, Harrison,
[46:17.960 --> 46:20.960]  claro, a mí se me salen las manos después de decirles si se puede o no.
[46:23.440 --> 46:27.160]  Bueno, ¿qué más no se puede hacer? Usar structs.
[46:29.600 --> 46:36.320]  Cierto. Bueno, para la gestión del TV, sí, porque tenemos que usar structs, pero para algo más adelante,
[46:36.320 --> 46:43.680]  listo. No se pueden usar uniones, eso por ese lado, uniones, que la verdad no sé qué es,
[46:43.680 --> 46:49.280]  pero supongo que será un método que se puede usar. Pues en este caso, si ustedes lo conocen,
[46:49.280 --> 46:56.880]  pues no lo usen. Type Dev tampoco, si hay una manera de definir tipos customizados de variables,
[46:56.880 --> 47:05.320]  no lo pueden usar. Ya les mostré pues qué formas podemos usar para definir eso. Y todo tiene que
[47:05.320 --> 47:10.560]  ser con variables apuntadores, ¿cierto? Pues ustedes cuando hacen el llamado al malloc, por ejemplo,
[47:11.520 --> 47:20.480]  memoria. Espérame, yo veo que yo tengo que calcular. ¿A dónde estás, malloc? Acá.
[47:21.680 --> 47:27.480]  Pues ustedes pueden acceder a una variable que se llame morenicio, start, o como quieran, o TV,
[47:27.480 --> 47:31.200]  no sé qué. Bueno, ya es de decisión de ustedes, con la creatividad de variables.
[47:31.200 --> 47:38.640]  Ustedes acá van a guardar la referencia de dónde comienza el espacio que ustedes reservan, ¿cierto?
[47:39.480 --> 47:44.880]  O sea, ah, bueno, y todo va a depender de cómo se quieran desplazar ustedes para básicamente
[47:44.880 --> 47:51.480]  hacer esto. ¿Por qué? Porque cuando ustedes impriman pueden hacer, por ejemplo, partición
[47:51.480 --> 47:58.240]  inicio. Entonces, ¿qué les va a imprimir partición inicio? Si esto de aquí hace referencia a la,
[47:58.240 --> 48:04.200]  por ejemplo, supongamos que está acá, literalmente, a la primera partecita de la memoria. ¿Eso qué
[48:04.200 --> 48:12.360]  imprimiría? Sí, pues sí, lo estamos guardando en este orden. Sí, pues usted lo puede guardar en
[48:12.360 --> 48:21.640]  el orden que quiera. Bueno, básicamente, pues eso va a imprimir la dirección de memoria en
[48:21.640 --> 48:26.600]  decimal, ¿cierto? Entonces, pues partición inicio, entonces me va a apuntar a partición inicio,
[48:26.600 --> 48:34.520]  me va a dar básicamente la dirección de memoria en decimal. Ahora, ustedes entonces,
[48:34.520 --> 48:38.520]  ¿cómo harían para ahora acceder al número de páginas en decimal?
[48:47.640 --> 48:53.160]  Bueno, pues básicamente lo que pueden hacer es desplazarse, entonces para eso se hace un
[48:53.160 --> 48:57.400]  casteo de la siguiente manera, que realmente, pues yo creo que la manera más óptima de hacer
[48:57.400 --> 49:04.040]  eso es el, del malloc. Entonces, ustedes castean una puntadora char, char pointer, ¿cierto? Que
[49:04.040 --> 49:08.240]  es lo que les va a permitir, básicamente. Yo no sé si ustedes recuerdan que cuando uno llamaba un
[49:08.240 --> 49:14.360]  malloc con un número entero, cada que ustedes le sumaban uno, uno se movía la cantidad del tamaño
[49:14.360 --> 49:20.000]  de un entero, que para esta arquitectura, pues son 4 bytes, ¿cierto? Que eso, pues imagino, eso lo
[49:20.000 --> 49:27.720]  vimos, pues justo en los ejemplos de los quizzes. Entonces, pues a mí me conviene más, si yo voy
[49:27.720 --> 49:35.600]  a trabajar con estos strings, por ejemplo, moverme, pues de a 1 byte, eso es mucho más fácil. Entonces,
[49:35.600 --> 49:40.280]  pues yo simplemente no lo llamo como un entero, sino que lo llamo como un char. ¿Para qué? Para que cada
[49:40.280 --> 49:45.960]  que yo le sume uno, pues no me sume 4 bytes, sino que me sume 1 byte, ¿cierto? Ya así es sencillo,
[49:45.960 --> 49:52.640]  entonces char, entonces esto es un malloc, y ya les había dicho que era 5 veces el tamaño de cada
[49:52.640 --> 49:57.560]  partición, no sé, partición, ¿cierto? Partición o pedacito como ustedes le quieran colocar, pues la
[49:57.560 --> 50:02.640]  partición, por ejemplo, acá es 46. Ustedes pueden llegar a que su partición mía 50, mía, depende
[50:02.640 --> 50:06.840]  del tipo de arelas que ustedes quieran usar, listo. Ustedes son libres de hacer lo que quieran con esas
[50:06.840 --> 50:14.120]  variables. Bueno, desde por ese lado, listo. ¿Hay alguna pregunta con eso? Todo bien.
[50:15.960 --> 50:27.240]  Listo, super. Bueno, entonces, pues, como ya les había dicho, pues no se pueden usar estructuras
[50:27.240 --> 50:31.920]  de ningún tipo, entonces todo es con apuntadores, ¿sí? Todo es con apuntadores.
[50:34.320 --> 50:35.040]  ¿Qué más?
[50:38.280 --> 50:45.680]  A ver, ¿qué más me dice por aquí? Ah, listo, esto es importante. Mire, dice que el máximo de
[50:45.680 --> 50:50.600]  variables apuntadores en la gestión del TLB, dice que son tres por función que necesiten,
[50:50.600 --> 50:58.280]  entonces, ¿cuántos punteros máximo pueden usar? Entonces, máximo tres punteros, listo.
[51:00.560 --> 51:06.000]  ¿Qué pueden hacer ustedes? El ejemplo que yo les di. Ustedes definen una variable que se
[51:06.000 --> 51:10.360]  llame el inicio, y entonces para ustedes hacer ciertas operaciones, pero lo que pueden hacer
[51:10.360 --> 51:14.960]  simplemente es sumarle bytes, y miren que ustedes están usando un sólito apuntador.
[51:15.840 --> 51:20.240]  Ahora, ustedes también pueden tener algo que, por ejemplo, les cuente...
[51:22.560 --> 51:26.440]  Bueno, es que acá no me están hablando. Solamente me están diciendo hacer cada apuntador, ¿sí?
[51:26.440 --> 51:29.840]  Entonces, si me están hablando solo de apuntadores, pues entonces, por ejemplo,
[51:29.840 --> 51:34.400]  pues si yo lo hago con desplazar, pues sumándole a bytes, pues entonces estaría usando un solo
[51:35.560 --> 51:41.240]  puntero. Ahora, pues puede que ustedes tengan, por ejemplo, pues no sé, un puntero uno que sea
[51:41.240 --> 51:47.680]  el inicio, ¿cierto? Un puntero dos que sea, no sé, el inicio más cuatro, o algo así.
[51:48.880 --> 51:52.920]  Y otro que sea el puntero tres, que sea el inicio más ocho, o algo así.
[51:55.000 --> 51:59.800]  Y ahí ustedes gastaron los tres punteros. ¿Qué es más fácil? Pues básicamente usar uno y sumarle
[51:59.800 --> 52:05.840]  bytes. Pues así es sencillo. Listo. Entonces, eso es como mi recomendación por ese lado.
[52:05.840 --> 52:14.760]  Ahora, listo. Importante. Entonces vamos a hacer una línea así. Porque esto es otra cosa totalmente,
[52:14.760 --> 52:19.360]  aparte de que eso nunca me lo explicaron, pues al menos que yo me acuerde. Entonces,
[52:19.360 --> 52:25.840]  ¿cómo obtener el tiempo? ¿Cierto? Porque si ustedes lo recuerdan, a mí me están pidiendo el
[52:25.840 --> 52:31.760]  tiempo de la operación que uno hace, ¿cierto? Pues en ese caso, pues es consultar la dirección
[52:31.760 --> 52:40.200]  en decimal, transformarla, hacer todo lo necesario, acceder básicamente a la memoria y ver si esa
[52:40.200 --> 52:51.080]  dirección ya existe. Y bueno, entonces básicamente yo tengo que calcular el tiempo que me tarda
[52:51.080 --> 52:56.520]  haciendo eso. Entonces, ¿cómo obtener el tiempo? Ahí el profe está diciendo que ustedes lo tienen
[52:56.520 --> 53:06.600]  que hallar con algo que se llama GetTimeOfDay. Entonces, GetTimeOfDay. Así pegadito. Listo.
[53:06.600 --> 53:13.320]  No sé por qué se me separa. Pues es así. Para ustedes usar esto, tienen que importar una librería
[53:13.320 --> 53:27.600]  que se llama, se lo voy a poner por acá entre paréntesis. Esto es un include. SysTime.h. Listo.
[53:29.120 --> 53:37.080]  Ustedes incluyen esa librería y ya con eso pueden básicamente hacer todo lo que necesitan
[53:37.680 --> 53:44.080]  para el tema del tiempo. ¿Qué otras librerías pueden importar? Las que ustedes consideren y que
[53:44.080 --> 53:48.600]  no les se les hayan prohibido porque por ahí se les prohíben algunas listas. ¿Qué les recomendaría
[53:48.600 --> 53:57.000]  yo? Pues la de siempre. Un stdint, tranquilo. Un stdio, de toda la vida. Un stlib, ¿cierto?
[53:57.000 --> 54:02.200]  Estas son las tres esenciales. Y también les recomendaría que incluyan string. Para que ese
[54:02.200 --> 54:09.800]  string, esta librería string tiene unos métodos que básicamente a mí me sirven para, por ejemplo,
[54:09.800 --> 54:16.240]  hacer comparaciones de strings. Por ejemplo, está el método str.comp.smp, que a mí me sirve
[54:16.240 --> 54:22.560]  básicamente para saber si un entero es igual a algo. Un string, perdón, es igual a algo, ¿cierto?
[54:22.560 --> 54:29.680]  O sea, por ejemplo, si s igual a s. ¿Qué ustedes lo van a necesitar? Pues básicamente para ver si lo
[54:29.680 --> 54:33.600]  que les ingresaron pues es un s. Entonces pueden usar este método, por ejemplo, pues ustedes buscan
[54:33.600 --> 54:40.480]  str.comp.manual o implementación, no le preguntan a chatgpt y ahí van a entender, listo. Esa es mi
[54:40.480 --> 54:45.880]  recomendación con respecto a librerías. Entonces, ¿cómo usamos getTimeOfDay? Esto tiene una forma
[54:45.880 --> 54:51.360]  de usarse. De hecho, en la librería, bueno, en la propia documentación, a ustedes les dicen
[54:51.360 --> 55:00.360]  cómo hacer eso, listo. Ah, bueno, muchachos, antes de que se me olvide, si ustedes lo recuerdan,
[55:00.360 --> 55:09.120]  nosotros cuando posiblemente ingresamos algo por consola, pues como ustedes tienen que recibir
[55:09.120 --> 55:13.880]  tanto un s, que es un string, como números en decimal, ¿cierto? Entonces, ¿yo cómo hago para,
[55:13.880 --> 55:21.320]  pues para recibir ambos? Pues nada, básicamente, pues ustedes tienen que transformar pues los números
[55:21.320 --> 55:29.000]  en, por ejemplo, un long long, que es un número grande, pues, o los pueden transformar en un
[55:29.000 --> 55:33.160]  entero, pues realmente desconozco si les va a dar error o no, pero pues hay un montón de tipados
[55:33.160 --> 55:38.120]  que pueden usar para hacer esas cosas. Para eso hacen toda la librería string, pues si ustedes
[55:38.120 --> 55:41.720]  pueden recibir la entrada y si, por ejemplo, la quieren transformar en un long long, pues entonces
[55:41.720 --> 55:52.240]  está este método que se llama str.ll, listo. Bueno, listo. Ah, bueno, listo. Y los cálculos de estas
[55:52.240 --> 55:57.040]  páginas, que eso también se me había olvidado mostrarles, ustedes van a recibir la memoria en
[55:57.040 --> 56:08.280]  decimal, ¿cierto? Supongamos que nos van a dar la dirección final, 4294.967.295, listo. Esta es la
[56:08.320 --> 56:13.920]  dirección final que ustedes pueden recibir. Ahora, ¿yo cómo hago para hallar el número de página en
[56:13.920 --> 56:18.240]  decimal y el desplazamiento en decimal? Pues entonces ustedes lo que hacen es hacer una
[56:18.240 --> 56:21.840]  división en un módulo, que eso es lo que yo les estaba mostrando. Les llegan y dicen esto por
[56:21.840 --> 56:28.000]  4.096 y esto les debería dar la página. Alguien que haga esa división a ver cuánto le da.
[56:29.040 --> 56:38.160]  Y luego para hallar el desplazamiento 4294.967.295 y esto módulo 4.096.
[56:38.560 --> 56:45.360]  ¿Para qué? Porque recuerden que el sobrante de esta división me indica básicamente pues qué
[56:45.360 --> 56:50.400]  pedacitico de página me tengo, me quedo sobrando. O sea, por ejemplo, supongamos que me da la página,
[56:50.400 --> 56:57.640]  que esta división me da 1953.4, no sé qué, bla, bla, bla. Entonces miren que acá la página
[56:57.640 --> 57:03.360]  pues sería la 1953. Ahora, este decimal de acá ¿qué significa? Pues miren que esto es un pedacito
[57:03.360 --> 57:06.840]  de página. Si a mí me están hablando de un pedacito de página, pues entonces eso quiere decir
[57:06.840 --> 57:12.280]  pues que ese pedacito tiene que ser parte de otra página. Entonces acá pues básicamente pues de la
[57:12.280 --> 57:21.720]  página 1953 y este aquí es el desplazamiento. Listo. O sea, no como que el decimal haga referencia a
[57:21.720 --> 57:26.080]  otra página, sino que literalmente pues es el desplazamiento dentro de la página. Entonces
[57:26.080 --> 57:31.400]  hagamos estas divisiones. Para ponerles un ejemplo, que eso me imagino que está por ahí, pues igual
[57:31.600 --> 57:44.960]  un ejemplo del profe. Ustedes pueden corroborarlo. A ver, 4294.967.295. Esto dio 4096. Esto me da
[57:44.960 --> 57:55.960]  1.048.575. Y ese sería el número de la página. Ahora, como esta división medio exacta, entonces
[57:55.960 --> 58:02.040]  hay que pasar con nada. El desplazamiento es cero. Ya, así de fácil. Cierto, porque de todas maneras eso
[58:02.040 --> 58:07.720]  ni siquiera tienen que preocuparse. Pues de plano, pues si ustedes hacen el módulo de
[58:07.720 --> 58:12.520]  esta división, pues eso les va a dar un cero. Entonces ustedes pueden implementar por ahí,
[58:12.520 --> 58:21.800]  pues una variable que les calcule esto. Listo, ahora sigamos con lo de GetTimeOfDay. Entonces,
[58:21.800 --> 58:28.600]  con GetTimeOfDay, ¿qué hay que hacer? Listo, entonces lo primero es definir una estructura.
[58:28.600 --> 58:38.440]  Esperen, yo lo tengo por acá, que se llama aquí. Entonces esto es un struct. Mire, aquí sí se puede
[58:38.440 --> 58:42.760]  usar el struct. ¿Por qué? Porque el struct no lo podemos usar para hacer la gestión del TLB. Ahora,
[58:42.760 --> 58:46.960]  esto es algo totalmente aparte y por eso es que les estoy colocando una raya, para que se den
[58:46.960 --> 58:53.640]  cuenta que es algo diferente. Esa casi pueden usar el struct. Yo creo que estos nombres de variables
[58:53.640 --> 58:57.720]  son predefinidos y yo creo que yo les intenté cambiar en un medio. Entonces, básicamente,
[58:57.720 --> 59:03.520]  pues yo no creo que haya problemas con que los use. Entonces, es que te generan un struct TimeVal y
[59:03.520 --> 59:09.240]  colocan un inicio y un final. ¿Cierto? Esas dos variables pues me van a indicar básicamente,
[59:09.240 --> 59:17.320]  pues el inicio y el final del tiempo. Ahora, ahí sí usamos ese método. Se llama GetTimeOfDay.
[59:17.320 --> 59:26.880]  Entonces, GetTimeOfDay y pues vamos a empezar en el inicio, ¿cierto? Entonces vamos a acceder a la
[59:26.880 --> 59:31.640]  dirección de inicio y pues yo le paso un null. No sé qué parámetro se le pueda pasar acá,
[59:31.640 --> 59:38.480]  pero yo le paso un null y con ese medio. Ahora, entonces ahí sí, ustedes lo que van a hacer,
[59:38.480 --> 59:43.920]  básicamente, es hacer toda su gestión del TV, ¿cierto? Entonces pueden ser, por ejemplo,
[59:43.920 --> 59:50.240]  apuntar, por ejemplo, al inicio. Mirar si la entrada corresponde a lo que les están dando
[59:50.240 --> 59:56.360]  acá arriba, ¿cierto? Ahora, yo en esta sesión no planeo darles como orientaciones sobre el código,
[59:56.360 --> 01:00:02.360]  pues la idea es que ustedes recuerden como los conceptos DCI, con Harrison,
[01:00:02.360 --> 01:00:07.080]  si pueden hablar de código y eso, ¿cierto? Pero la idea de esta sesión es que sea, pues,
[01:00:07.080 --> 01:00:10.400]  más bien teórica para que ustedes entiendan, pues, en esencia que es lo que tienen que hacer,
[01:00:10.400 --> 01:00:16.600]  ¿cierto? Eso es como lo más importante. Bueno, entonces, con ese GetTimeOfDay ustedes lo
[01:00:16.600 --> 01:00:21.360]  inicializan, hacen todo lo que necesitan hacer del TV, ¿cierto? Yo que les recomendaría, pues,
[01:00:21.360 --> 01:00:26.560]  eso lo pueden hacer, esto que hacen acá, pues, lo pueden hacer después de haber declarado todas
[01:00:26.560 --> 01:00:34.040]  las, como tal, las, o sea, después de la entrada, ¿cierto? O sea, básicamente, si ustedes les ingresan
[01:00:34.040 --> 01:00:37.920]  una dirección de memoria, tata, tata, tata, comprueban que no se les exceda este numerote que
[01:00:37.920 --> 01:00:44.640]  tenemos por aquí, bueno, yo lo borré, pero recuerden, pues, si se les excede 4294 millones,
[01:00:44.640 --> 01:00:53.560]  bla, bla, bla, eso es un page fault, listo. En otro caso, pues, entonces, sería una dirección
[01:00:53.560 --> 01:01:01.840]  válida y entonces hacen todo lo que necesitan hacer del TV, ¿cierto? Listo. A ver, ¿qué más?
[01:01:01.840 --> 01:01:06.880]  Bueno, eso por ese lado, entonces, listo. Hacen todo lo que necesitan hacer del TV,
[01:01:06.880 --> 01:01:16.600]  hacen la consulta, tal, y ya entonces ahí sí que ustedes encuentran algo o, por ejemplo, guardan
[01:01:16.600 --> 01:01:24.480]  algo. Entonces, ahí, ya ahí sí, pues, después de que hagan todo lo que necesitan hacer, entonces,
[01:01:24.480 --> 01:01:31.440]  van a hacer lo siguiente. Van a volver a usar ese método GetTimeOfDay. Sí, esto, pues,
[01:01:31.440 --> 01:01:38.720]  es continuo. Pues, no estoy pasando de página, pero es continuo. GetTimeOfDay y ahora le van
[01:01:38.720 --> 01:01:44.560]  a pasar la dirección del final, ¿sí? ¿Por qué? Porque básicamente en estas dos variables se me
[01:01:44.560 --> 01:01:51.560]  están guardando el tiempo inicio y el tiempo final y acá le pasamos el null también. Ahora, ahí sí,
[01:01:51.560 --> 01:01:56.960]  ¿nosotros qué hacemos con esas cosas de start y de end? Pues, entonces, vamos a hacer lo siguiente,
[01:01:56.960 --> 01:02:05.320]  que esos sí son métodos que tienen definidos la propia librería list. Entonces, vamos a hacer
[01:02:05.320 --> 01:02:12.280]  lo siguiente. Pues, por ejemplo, esto va a ser un decimal y un poquito larguito que el profe,
[01:02:12.280 --> 01:02:20.040]  pues, acá en los ejemplos que él expone, por ejemplo, dice tiempo 0.00000053 segundos. Ay,
[01:02:20.040 --> 01:02:23.480]  Juanmario, ese número tan grande, pues, con tantos decimales, pues, nada, hacemos un double.
[01:02:23.800 --> 01:02:28.480]  Tenemos un double y ahí pueden ponerle el nombre de Aurelio que ustedes quieran. Le pueden poner
[01:02:28.480 --> 01:02:37.480]  tiempito, time, no sé, tiempo mío, tiempo Samuel, tiempo cualquiera de su nombre, como quieran. Sí,
[01:02:37.480 --> 01:02:42.600]  pues, ya ves, eso lo dejar, esas variables en el código, pues, como para que el profe vea que el
[01:02:42.600 --> 01:02:50.440]  trabajo sí es mío. Entonces, bueno, vamos a decirle que es tiempo Juanito. Listo, en tiempo Juanito,
[01:02:50.440 --> 01:03:00.360]  entonces, ¿qué vamos a hacer? Básicamente, a mí, esas dos variables van a guardar lo siguiente. Van
[01:03:00.360 --> 01:03:09.520]  a guardar una cosa que se llama el TVSec y otra cosa que se llama el TVUsec. Básicamente,
[01:03:09.520 --> 01:03:16.680]  ¿qué es cada uno? Este es el tiempo en segundos y este es el tiempo en milisegundos. Milisegundos
[01:03:16.680 --> 01:03:24.200]  o microsegundos. Esperenme, yo miro un momentico. Porque a este hay que hacerle una división.
[01:03:30.760 --> 01:03:34.200]  Por aquí lo tengo, TV, timeval.
[01:03:37.720 --> 01:03:45.520]  Ah, microsegundos, son microsegundos, listo. Son microsegundos. Entonces, como sabemos que son
[01:03:45.520 --> 01:03:50.360]  microsegundos y a mí en el anuncio me dicen que yo tengo que dar el tiempo completo en segundos,
[01:03:50.360 --> 01:03:54.880]  entonces, obviamente, pues, yo esto no lo puedo votar, empezando porque es muy probable que TVSec
[01:03:54.880 --> 01:04:01.120]  sea cero. ¿Por qué? Porque es que los computadores son una rapidez y les hallan eso en 0.000000053,
[01:04:01.120 --> 01:04:07.880]  algo así, segundos. Pues, entonces, yo, ¿cómo hago esta porción? Pues, con el Usec, listo. Y,
[01:04:07.880 --> 01:04:13.960]  entonces, solo tengo que pasar a segundos. Ahora, pues, realmente, uno, pues, llega y dice, ah, pues,
[01:04:13.960 --> 01:04:23.480]  busca en Google, ¿cómo paso de microsegundos a segundos? Entonces, aquí me dice que un microsegundo,
[01:04:25.160 --> 01:04:30.600]  bueno, es que me dices milisegundos, vamos a ponerle, pues, que yo conozca la anotación de
[01:04:30.600 --> 01:04:54.560]  microsegundos, entonces, 1 por 10 a la menos 6 segundos. O sea, esto es un 0.0000001 segundos.
[01:04:54.560 --> 01:05:00.680]  Listo. O sea, esto es un microsegundo en segundos. Ahora, obviamente, pues, eso no se va a demorar
[01:05:00.680 --> 01:05:04.640]  tan poquito, pues, ustedes les van a dar una cantidad de microsegundos, pues, obviamente,
[01:05:04.640 --> 01:05:10.240]  considerable. Les pueden darnos de 40.000 microsegundos. Pues, obviamente, entonces,
[01:05:10.240 --> 01:05:15.800]  es deber de ustedes, pues, hacer este cálculo. ¿Cómo lo hacen? Nada, pues, dividen por 1 por 10
[01:05:15.800 --> 01:05:22.600]  a la 6. ¿Cómo se hace eso en cento? Ya les voy a mostrar. Listo. Entonces, ya que les mostré esto,
[01:05:22.600 --> 01:05:32.320]  entonces, vamos ahora sí a ver cómo se hace. Ustedes llegan y dicen, listo. Como yo tengo un
[01:05:32.320 --> 01:05:40.680]  tiempo de final, mejor la voy a hacer así, como con la recta numérica, eso que creo que es un
[01:05:40.680 --> 01:05:47.240]  ejemplo más entendido. Esta es mi posición de inicio, entonces, esto es start. Y acá, por acá,
[01:05:47.240 --> 01:05:52.880]  ya terminó. Entonces, esto es un end. Y por acá se demoró, no sé cuánta cantidad de segundos y
[01:05:52.880 --> 01:06:04.480]  microsegundos. ¿Ustedes cómo hacen para allá esta magnitud? ¿Cómo harían por hacer eso? Una
[01:06:04.480 --> 01:06:10.800]  resta, listo. ¿A quién vas a restar? El final menos el inicio. El final menos el inicio. Perfecto.
[01:06:10.800 --> 01:06:17.240]  Listo. Eso es todo. Como es el final menos el inicio y yo tengo un tiempo en segundos y un
[01:06:17.240 --> 01:06:25.040]  tiempo en microsegundos, cada uno del inicio y el final. Nada, entonces, llegamos, cogemos por
[01:06:25.040 --> 01:06:29.040]  aquí. ¿Por qué hay que hacer esto, muchachos? Porque es que el tiempo de inicio no es ser. El
[01:06:29.040 --> 01:06:35.600]  tiempo de inicio es la hora que ustedes tengan en su computador. Miren que eso es muy chévere. Para
[01:06:35.600 --> 01:06:41.840]  eso se importa entonces SISTIME. Todo lo que sea SIS algo es porque están usando algo del
[01:06:41.840 --> 01:06:46.320]  computador. Miren que si es SISTIME, entonces ustedes están importando básicamente el tiempo,
[01:06:46.320 --> 01:06:51.040]  la hora actual de su computador. Con esa misma hora, entonces, lo que hace es básicamente calcular
[01:06:51.040 --> 01:06:57.080]  pues cuál es la actual hora. Por eso dice GET TIME OF DAY. Ustedes usan un GET TIME OF DAY y en
[01:06:57.080 --> 01:07:01.760]  start guardan la hora de inicio. Y en el GET TIME OF DAY y en el final guardan la hora en la que se
[01:07:01.760 --> 01:07:08.480]  acabó. Ahora, esa hora ustedes se la van a guardar en segundos y en microsegundos. Entonces,
[01:07:08.480 --> 01:07:16.960]  pues, por eso básicamente hacemos esto. Ah, ya se me empezaron a ir. Bueno, a ver,
[01:07:16.960 --> 01:07:22.520]  los voy a coger antes de que se me empiecen a ir, muchachos, para ver si me pueden colaborar
[01:07:22.520 --> 01:07:27.640]  con lo de la asistencia. Se las voy a mandar al chat.
[01:07:31.760 --> 01:07:39.080]  Es importante porque a mí me revisan cuánta gente asiste. Entonces, es importante que
[01:07:39.080 --> 01:07:46.720]  todos los que estén aparezcan ahí. Asistencia y valoración de talleres. Aquí está.
[01:07:48.080 --> 01:07:54.480]  Se pueden llenar por fase formularia. Yo se los agradezco mucho. Lo pueden llenar ahorita.
[01:07:54.480 --> 01:07:59.160]  La idea es que lo llenen ahorita para que no se les olvide, pero bueno, con eso me ayudaría
[01:07:59.160 --> 01:08:05.560]  bastante. Listo. Entonces, básicamente, ¿qué tenemos que hacer? Entonces, restar el tiempo de
[01:08:05.560 --> 01:08:11.080]  final menos el de inicio, ¿cierto? O sea, la hora de inicio menos la hora de final menos la inicio.
[01:08:11.080 --> 01:08:16.560]  Entonces, ¿cómo hacemos eso? Primero, calculemos el tiempo en segundos. Entonces, accedemos a lo
[01:08:16.560 --> 01:08:22.440]  que se demoró en segundos del final. Entonces, en .tv y en bajo sec. Y le restamos lo del principio.
[01:08:22.440 --> 01:08:28.640]  ¿Cuál era el principio? Star. Entonces, es tan fácil. Como decir Star.tv sec. Ya tenemos el
[01:08:28.640 --> 01:08:40.600]  tiempo en segundos. ¿Qué nos falta? ¿El tiempo en qué? ¿En qué?
[01:08:44.480 --> 01:08:50.600]  El micro. El micro segundos. ¿Qué será USEC? Nada. Pues, entonces, sumémosle ese tiempo.
[01:08:50.600 --> 01:08:58.760]  Entonces, sería en .tv y en bajo USEC. Y esto restado pues del tiempo de inicio,
[01:08:58.760 --> 01:09:11.880]  pero en micro segundos. Ah, se me acabó. .tv y en bajo USEC. Ya. Listo. Entonces, así ustedes...
[01:09:11.880 --> 01:09:16.120]  Ah, bueno, listo. Falta algo súper importante. Si ustedes se acuerdan que esto así solito no
[01:09:16.120 --> 01:09:21.360]  significa los segundos. Nada. Entonces, esto que nos está dando acá, pues llegamos y lo dividimos
[01:09:21.360 --> 01:09:27.160]  por uno exponencial seis. Así tal cual lo pueden escribir en el lenguaje y les va a dar. Listo.
[01:09:28.160 --> 01:09:33.200]  Entonces, miren que con este calculito, pues entonces, esto llega. Y ese es el tiempo en
[01:09:33.200 --> 01:09:36.960]  segundos que muy probablemente sea... Bueno, es que si ustedes lo recuerdan, no es que realmente
[01:09:36.960 --> 01:09:42.200]  este tiempo en segundos sea cero. Sino que, imagínense que nosotros empezamos a las 7.53 p.m.
[01:09:42.200 --> 01:09:50.200]  Y terminamos esa consulta pues a las 7.53 p.m. Ahora, por debajo, pues el computador pues maneja
[01:09:50.200 --> 01:09:55.360]  la hora pues en unas unidades muy pequeñas, ¿cierto? Entonces, pues básicamente miren que aquí no ha
[01:09:55.360 --> 01:10:00.280]  transcurrido ningún segundo. Entonces, es muy probable que esa resta pues les debe ser, ¿cierto?
[01:10:00.280 --> 01:10:07.880]  Pues 7.53 menos 7.53 pues les va a dar cero en segundos. Ahora, pues la micro... Esa parte tan
[01:10:07.880 --> 01:10:14.000]  pequeñita de micro segundos pues sí está. Y es importante que en otro la coloquemos. Ahora,
[01:10:14.000 --> 01:10:20.200]  no es que todo se tenga que ir por uno exponencial seis. Ojo, solamente esta parte de aquí. Listo.
[01:10:20.200 --> 01:10:25.240]  Pues ustedes pueden colocar, por ejemplo, no sé, otro paréntesis como ustedes quieran, ¿cierto? Ya
[01:10:25.240 --> 01:10:32.920]  pues en caso de que ustedes les quede como mejores. Bueno, a ver qué más tiene el enunciador,
[01:10:33.080 --> 01:10:45.240]  qué más les puedo decir. Ya les dije lo del page vault. Ah, bueno, listo. Lo otro es que ustedes
[01:10:45.240 --> 01:10:53.280]  básicamente tienen que hacer una función que les convierta un número decimal a binario y un
[01:10:53.280 --> 01:11:00.040]  número binario a decimal, ¿cierto? Si ustedes lo recuerdan, entonces primero les voy a explicar
[01:11:00.040 --> 01:11:08.200]  la binaria decimal. Listo. Entonces para acá tenemos... Vamos a suponer un decimal de unos
[01:11:08.200 --> 01:11:17.440]  cinco bits. Entonces recuerden que este es el 2 a la cero, este es el 2 a la uno, este es el 2 a la
[01:11:17.440 --> 01:11:22.880]  dos, este es el 2 a la tres, este es el 2 a la cuatro. Allí se van yendo los números en decimal.
[01:11:22.880 --> 01:11:27.160]  En binario, perdón. ¿Cuántos entonces van a tener ustedes a la final? Ustedes van a quedar
[01:11:27.160 --> 01:11:32.400]  pues básicamente con un 2 a la 31 por acá al final, ¿cierto? ¿Por qué? Porque es que están
[01:11:32.400 --> 01:11:36.880]  contando el cero. Y si son 32 bits, pues entonces se cuenta como uno, dos, tres, cuatro, cinco. Así
[01:11:36.880 --> 01:11:46.200]  está 32 bits. Listo. ¿Cómo hacen ustedes entonces para hacer esa función? Ustedes reciben la cadena
[01:11:46.200 --> 01:11:51.480]  de strings, pues la cadena de charts, perdón, que es un cero uno, cero, cero uno, cero, cero,
[01:11:52.200 --> 01:11:57.720]  y pues básicamente, pues como eso es una cadena, pues nada, ustedes pueden iterar sobre esa cadena
[01:11:57.720 --> 01:12:03.800]  accediendo a las posiciones de él, pues con un ni, un for, ¿cierto? Ustedes pueden hacer un for para
[01:12:03.800 --> 01:12:11.120]  recorrer la cadena. ¿Qué pueden hacer? Entonces nada, pues pueden ir del 2 a la 31 para atrás
[01:12:11.120 --> 01:12:17.760]  y llegar y decir, ah bueno, listo, entonces en la posición 2 a la 31 yo tengo un uno,
[01:12:18.320 --> 01:12:25.880]  sí, ah bueno, listo, entonces llega y pues recuerden que los números en binario se calculan así.
[01:12:25.880 --> 01:12:33.440]  Vamos a suponer que tenemos un uno, cero, cero, uno, uno. Si yo tengo un uno en esta posición, a mí,
[01:12:34.560 --> 01:12:39.960]  esto al final va a ser una suma. ¿De quiénes de estas potencias? Entonces si yo tengo un uno en dos
[01:12:39.960 --> 01:12:45.040]  a la cero, entonces pongo dos a la cero. Si yo tengo un cero en dos a la uno, no lo pongo. Si
[01:12:45.040 --> 01:12:49.120]  tengo un cero en dos a la dos, no lo pongo. Si tengo un uno en dos a la tres, lo pongo, ¿cierto?
[01:12:50.000 --> 01:12:54.040]  Entonces están dos a la tres. Tengo un uno en dos a la cuatro también, listo, entonces lo pongo.
[01:12:54.040 --> 01:13:00.160]  El resultado de esta suma me debería dar este número en binario, listo. ¿Por qué le estoy explicando
[01:13:00.160 --> 01:13:04.160]  esto? Porque ya no pueden usar la calculadora para hacer eso, porque tienen que hacer una función
[01:13:04.160 --> 01:13:09.440]  que calcule eso, ¿cierto? No sé si el profesor semestre les ha dado permiso de usar la librería
[01:13:09.440 --> 01:13:16.440]  mat.h, pero en su momento yo la hice con recursión. Lo pueden hacer como ustedes quieran, pues ya,
[01:13:16.440 --> 01:13:20.960]  pues calcular una potencia, pues yo creo que es como el 101 de funciones que uno crea como
[01:13:20.960 --> 01:13:28.160]  fundamento de programación. Listo, si hacemos este cálculo, esto me debería dar dos a la cero,
[01:13:28.160 --> 01:13:35.040]  me da uno, dos a la tres, dos por dos cuatro por dos ocho, me da ocho, y otra vez por dos por dieciséis,
[01:13:35.240 --> 01:13:41.320]  ya, así es sencillo. Entonces este numerito me debería dar 25. Si yo me voy acá a mi calculadora
[01:13:41.320 --> 01:13:49.560]  de Windows, denme un segundo, si yo me voy acá a mi calculadora de Windows, entonces yo tengo que
[01:13:49.560 --> 01:13:58.640]  el número en binario era 11001. Miren que en efecto me dio 25, ¿sí o qué? Que eso era lo que yo tenía,
[01:13:58.640 --> 01:14:09.120]  pues por aquí. Es que no se alcanza a dejar. Pues en todo caso, para que vean que sí concuerda.
[01:14:11.960 --> 01:14:19.080]  En todo caso, para que vean que sí concuerda, ¿sí o qué? Ya, pues listo. Miren que así se convierte
[01:14:19.080 --> 01:14:23.840]  un número de binario decimal, pues nada más hago una función que, por ejemplo, yo tengo la cadena
[01:14:23.840 --> 01:14:32.120]  no sé, 10010101 o algo así. Que esto sea lo que reciba la función, ¿cierto? Pues esto es una cadena
[01:14:32.120 --> 01:14:36.520]  al fin y al cabo, entonces pues pueden usar, por ejemplo, ese método que yo les di de string.comp.
[01:14:36.520 --> 01:14:44.360]  ¿Para qué? Pues si es un cero, entonces no le haga nada, y si es un uno, entonces, pues miren
[01:14:44.360 --> 01:14:52.920]  qué índice está, por ejemplo, este está en el índice 27 y pues nada, ya llegan y cogen. Porque yo,
[01:14:52.920 --> 01:14:56.880]  por ejemplo, les recomendaría deterrar la cadena de atrás para adelante. ¿Para qué? Para que puedan
[01:14:56.880 --> 01:15:01.560]  hacerlo con la forma en la que yo les mostré, de derecha a izquierda, porque es que así es como están
[01:15:01.560 --> 01:15:06.120]  los binarios. Dos a la cero, dos a la uno, dos a la dos, y eso es sencillamente. Entonces, si tener una
[01:15:06.120 --> 01:15:10.400]  cadena de atrás para adelante, pues no tienen que preocupar por, pues es manejar este número,
[01:15:10.400 --> 01:15:15.760]  pues simplemente toman que el i es cero, que el i es uno, que el i es dos, y eso es sencillamente, listo.
[01:15:15.760 --> 01:15:30.680]  Bueno, y lo último que les tengo es la función que les calcula el número en decimal a binario.
[01:15:30.680 --> 01:15:41.600]  ¿Cómo se hace esto? Entonces, básicamente, lo que tienen que hacer es usar las operaciones de bitwise,
[01:15:41.600 --> 01:15:48.640]  ¿cierto? O sea, pueden usar el desplazamiento a la derecha, que eso se puede hacer así, y un operador
[01:15:48.640 --> 01:15:57.880]  AND bitwise. Muchachos, yo realmente no conozco mucho de esto, sí, en su momento lo aprendí como
[01:15:57.880 --> 01:16:03.640]  para hacer el trabajo, y la verdad no me acuerdo mucho. Hoy en día, pues sí conozco más eso de
[01:16:03.640 --> 01:16:08.520]  los bits, pero les voy a dar como la explicación de la que yo me acuerdo para hacer esa función,
[01:16:09.160 --> 01:16:14.600]  que yo la tengo pues acá obviamente escrita en mi código, pero si ustedes me preguntan hoy en día,
[01:16:14.600 --> 01:16:21.240]  pues esto cómo trabaja, la verdad no me acuerdo muy bien. Pero bueno, ah bueno, y lo otro, recuerden,
[01:16:21.240 --> 01:16:29.160]  recuerden, recuerden, yo no sé si Harrison les haya puesto esas restricciones hoy en este trabajo,
[01:16:29.160 --> 01:16:36.720]  pero al menos el monitor del semestre pasado lo que dijo fue que ustedes se van a encontrar con
[01:16:36.720 --> 01:16:45.360]  que no van a necesitar esas funciones para nada, ¿cierto? ¿Qué les recomiendo yo? Úsenlas, así,
[01:16:45.360 --> 01:16:52.960]  o sea, fuercen el uso, por ejemplo, ustedes pueden hacer, hallar la cadena en binario de la página,
[01:16:52.960 --> 01:17:01.480]  sí o qué, y no sé, pues conviertan este número que es el de la página a decimal y eso imprimanlo
[01:17:01.480 --> 01:17:07.960]  en su consola, ¿cierto? Y ahí estarían usando la función que crear y lo mismo con el otro,
[01:17:07.960 --> 01:17:11.760]  pues si en la página en decimal pues conviertan la binaria con la otra función y ahí estarían
[01:17:11.760 --> 01:17:21.240]  usando todo. Pues eso sería como mi recomendación. Bueno, ah bueno, otra cosita, les recomiendo
[01:17:21.240 --> 01:17:28.120]  muchísimo, muchísimo que estén revisando el enunciado a cada ratito, vayan haciendo el código
[01:17:28.120 --> 01:17:31.880]  normal, lo van escribiendo y vayan revisando el enunciado. ¿Por qué? Porque uno se va yendo
[01:17:31.880 --> 01:17:39.520]  así y va acordándose como varias cosas. ¿Y qué cosas puede usar o no? ¿Listo? Bueno,
[01:17:42.120 --> 01:17:48.000]  voy a buscar la documentación de esa cosa, del desplazamiento de bits, porque la verdad,
[01:17:51.120 --> 01:17:52.200]  cómo se usa,
[01:17:52.200 --> 01:18:08.760]  desplazamiento de bitsense y bitwise. Pues es que igual a también estas comparaciones con
[01:18:08.760 --> 01:18:13.320]  AND, ¿cómo funciona ese operador AND? Básicamente usted es en una cadena de binarios,
[01:18:13.960 --> 01:18:24.040]  0, 1, 0, 0, 1, 0, 1. Ustedes la pueden comparar con otra cadena, con el AND, ¿cierto? Y 0, 1, 1,
[01:18:24.040 --> 01:18:34.840]  0, 0, 1, 0. Eso es lo mismo que hacer básicamente comparaciones. 1 es true, 0 es false, ¿cierto? Así
[01:18:34.840 --> 01:18:41.800]  es fácil. Entonces, uno, pues eso me imagino que se acuerdan de matemáticas discretas,
[01:18:41.800 --> 01:18:49.840]  pues falso y verdadero me da falso, entonces esto es un 0. Falso y verdadero, falso. Verdader y
[01:18:49.840 --> 01:19:00.120]  verdadero, verdadero. Falso y falso, verdadero. Verdader y falso, falso. Esto acá es falso y
[01:19:00.120 --> 01:19:04.600]  verdadero me da falso y esto acá también me da igual. Entonces, ¿cuál es la cadena resultante
[01:19:04.600 --> 01:19:18.120]  haciéndole un AND? Pues esto, ¿sí? Ya, así de fácil. Listo. Y es que esto no lo entiendo muy bien
[01:19:18.120 --> 01:19:25.640]  porque el desplazamiento de bits se puede ver en divisiones de forma progresiva. Si ustedes
[01:19:25.640 --> 01:19:31.840]  lo recuerdan, esto termina siendo potencias. Si yo debía este número por 2, pues me haría dar este.
[01:19:31.840 --> 01:19:37.360]  Si yo debía este número por 2, pues me haría dar este. Si debía este por 2, pues me haría dar este y así
[01:19:37.360 --> 01:19:44.880]  de sencillamente, ¿cierto? Entonces, básicamente, pues cómo pueden hallar, porque la función
[01:19:44.880 --> 01:19:49.720]  básicamente es para hacer lo siguiente. Ustedes tienen un número en decimal, vamos a suponer que
[01:19:49.720 --> 01:19:59.000]  es 14, ¿cierto? Y yo necesito entonces con ese operador coger y desplazarlo hacia la derecha,
[01:19:59.000 --> 01:20:07.080]  pues básicamente para llegar y... Es que no sé, es que está más enredada. Porque no les quisiera
[01:20:07.080 --> 01:20:12.520]  pues mostrar cómo es esta función, porque si no, pues matan como el hecho de que lo hagan ustedes
[01:20:12.520 --> 01:20:17.880]  mismos y si ven todos como la misma función, pues obviamente van a coger la que ya funciona y esa
[01:20:17.880 --> 01:20:23.720]  no es la idea, ¿sí o qué? Pero pues les podría mostrar una forma de hacerlo.
[01:20:23.720 --> 01:20:33.120]  Bueno, vamos a hacerla así. Entonces, podemos iterar, por ejemplo, de...
[01:20:35.600 --> 01:20:38.720]  Es que cada vez lo tengo desde adelante hacia atrás y va aumentando.
[01:20:42.000 --> 01:20:48.320]  Porque la verdad es que como todo está... Porque puede pasar lo siguiente. Si ustedes llegan y
[01:20:48.440 --> 01:20:56.960]  quieren convertir, por ejemplo, pues lo que teníamos. Esto que tenemos acá. Ah, bueno,
[01:20:56.960 --> 01:21:02.720]  ya, ya, ya, ya, ya, ya. Ya entiendo. Miren. Ustedes cómo pueden hacer esto como yo lo tengo acá.
[01:21:02.720 --> 01:21:08.160]  Ustedes tienen, por ejemplo, un número. El número, pues básicamente va a ser la dirección que les
[01:21:08.160 --> 01:21:12.280]  están pasando o el número que sea que ustedes vayan a pasar en decimal, ¿cierto? Recuerdan que
[01:21:12.280 --> 01:21:17.040]  lo pueden usar. ¿Cuáles números tenemos en decimal? Pues la página, el desplazamiento,
[01:21:17.040 --> 01:21:22.800]  la dirección de memoria. La dirección de memoria pues yo la tengo que meter básicamente en decimal
[01:21:22.800 --> 01:21:28.760]  en la impresión. Ahora, pues yo les recomendaría hacer esos cálculos, pues como les mostré,
[01:21:28.760 --> 01:21:35.280]  pues dividir por 4096 y el módulo de 4096 para que haya en esto. Y eso lo pueden convertir a
[01:21:35.280 --> 01:21:44.440]  binario de esa manera. Entonces imagínense, ustedes tienen por ejemplo un 42. Si ustedes
[01:21:44.440 --> 01:21:55.320]  se dan a la calculadora, este número en binario debería darles 0 0 1 0 1 0 1 0. Listo,
[01:21:55.320 --> 01:22:02.120]  este número en binario significa 42. Es decir, ese número es el que tenemos que llegar en resumen.
[01:22:02.120 --> 01:22:14.240]  Ahora, ya estoy entendiendo más o menos qué es lo que está haciendo esto. A ver,
[01:22:14.240 --> 01:22:20.640]  ustedes qué pueden hacer. Con estos desplazamientos, bitwise, ustedes se desplazan
[01:22:20.640 --> 01:22:27.920]  literalmente bits. Si ustedes hacen, por ejemplo, un desplazamiento hacia la derecha 3, entonces
[01:22:27.920 --> 01:22:35.160]  literalmente pues ustedes se estarían desplazando 3 bits a la derecha. Pero es que,
[01:22:35.160 --> 01:22:47.240]  a ver, es que esto está más raro. Si yo desplazo esto a 3 bits, esto me da... ¿Si da así? Bueno,
[01:22:47.240 --> 01:22:52.160]  vamos a poner que sí. Miren, si ustedes tienen este binario, ¿cierto? Y ustedes se desplazan
[01:22:52.160 --> 01:22:57.080]  3 bits a la derecha, entonces este binario les va a quedar así. Recuerden que todos los números
[01:22:57.080 --> 01:23:01.280]  pues terminan siendo para el lenguaje binario. Entonces, si ustedes hacen esta operación en
[01:23:01.280 --> 01:23:07.440]  un desplazamiento 3, entonces este número les va a terminar dando el siguiente binario.
[01:23:09.520 --> 01:23:18.400]  Hay que correrse tres posiciones, ¿sí o qué? Entonces 0 0 0 1 0 1 0 1. Ya me corrí una. Listo,
[01:23:18.400 --> 01:23:27.400]  ahora corramos nosotras. Entonces agregamos otro 0 0 0 0 1 0 1 0. Y corramos nosotras,
[01:23:27.400 --> 01:23:36.880]  0 0 0 0 0 1 0 1. Este número de acá sería el número que nos daría en binario si yo
[01:23:36.880 --> 01:23:43.440]  me desplazara 3 bits a la derecha. ¿Tres bits a la derecha es igual? Listo. Entonces,
[01:23:43.440 --> 01:23:49.680]  ustedes ¿para qué pueden usar eso básicamente? Para irse desplazando e ir revisando si el número
[01:23:49.680 --> 01:23:57.120]  en la posición en la que yo estoy es un 1. ¿Cómo lo pueden hacer? Con el operador AN, ¿cierto?
[01:24:01.160 --> 01:24:08.040]  Aunque yo tengo acá que es que desplazo como un 1 a la izquierda y si es un 1, entonces póngale
[01:24:08.040 --> 01:24:15.920]  1 a la KN y si no es un 0. Con un operador ternario creo que se llama eso. La verdad es que se me sale
[01:24:15.920 --> 01:24:20.240]  un poquito de las manos como explicarles bien esto, porque la verdad pues no recuerdo muy bien,
[01:24:20.240 --> 01:24:25.760]  pero pues esto les recomendaría pues que le pregunten a Harrison, pues Harrison si sabe
[01:24:25.760 --> 01:24:31.240]  bastante pues como el DC como tal, pues hacer esas operaciones, entonces sería muy chévere pues que
[01:24:31.240 --> 01:24:39.000]  le preguntaron pues como de eso. Yo creo que por mi parte no tengo como nada más para hoy. Si tienen
[01:24:39.000 --> 01:24:44.080]  alguna pregunta de una pues queda el espacio como para que me hagan preguntas pues ya, como con
[01:24:44.080 --> 01:24:54.760]  respecto pues a todo. Pero pues en resumen sí, o sea tienen que hacer una función que les convierta
[01:24:54.760 --> 01:25:01.000]  un número de decimal a binario que se hace de esta manera o de binario a decimal que se
[01:25:01.000 --> 01:25:11.480]  hace con estas operaciones pues le pueden pedir ayuda a Chacho y Petit. ¿Alguna pregunta? ¿O todo bien?
[01:25:11.480 --> 01:25:22.640]  Samuel y Germán dicen que todo bien, Juan Diego dice que bien. Igual de todas maneras muchachos,
[01:25:22.640 --> 01:25:28.240]  cualquier cosita me escriben en el whatsapp, ustedes saben que yo estoy a su disposición,
[01:25:28.240 --> 01:25:36.160]  yo no les voy a acordar nada. Pues me pueden escribir sábado, domingo, pues yo sé que se trabaja
[01:25:36.160 --> 01:25:41.040]  para la luna. Si tienen alguna pregunta pues teórica me escriben de una, yo les contesto. Hago lo posible
[01:25:41.040 --> 01:25:45.080]  pues para contestarle porque igual pues yo también tengo una bien. Entonces pues si yo les puedo
[01:25:45.080 --> 01:25:49.520]  contestar y les puedo ayudar pues como con lo que necesitan, pues de una les ayudo, listo.
[01:25:51.520 --> 01:25:54.960]  Si, pues igual de todas maneras, si les surge alguna pregunta después de la sesión y ya se
[01:25:54.960 --> 01:25:59.120]  acabó pues me escriben en el whatsapp, ve parce pues cómo se hace esto, hágale que yo les ayudo.
[01:25:59.120 --> 01:26:03.320]  Pues ya tengo igual como referencia pues el trabajo que hice para el semestre pasado y pues
[01:26:03.320 --> 01:26:10.720]  este trabajo sacó cinco, entonces pues creo que es una buena referencia. Ah lo más importante se
[01:26:10.720 --> 01:26:17.560]  me ha olvidado. Miren muchachos, si ustedes se acuerdan, ustedes cada que piden memoria tienen
[01:26:17.560 --> 01:26:22.360]  que liberarla. ¿Cuál fue la memoria que ustedes pidieron? Una que teníamos por aquí que se hizo
[01:26:22.360 --> 01:26:31.880]  con malloc. ¿Cómo se libera un malloc? A ver si se acuerdan. Con el freeze. Ok, listo, entonces
[01:26:32.720 --> 01:26:37.880]  después de que acabe esto, o sea después de que el usuario escriba ese, no antes,
[01:26:37.880 --> 01:26:43.160]  pues entonces ustedes llegan y obviamente pues ya cuando acaben todo pues ustedes hacen un free.
[01:26:43.160 --> 01:26:46.320]  ¿De quién? ¿A quién le tienen que pasar como parámetro un free?
[01:26:48.320 --> 01:26:55.120]  El apuntador del malloc, ¿no? El apuntador del malloc, sí o qué, listo. Y eso yo le habíamos
[01:26:55.120 --> 01:27:03.800]  definido al inicio, ¿sí o qué? Yo les había dicho que le podían poner televestar, inicio,
[01:27:03.800 --> 01:27:09.960]  memoria inicio, ¿sí o qué? Entonces básicamente pues si ustedes tienen por acá una variable que
[01:27:09.960 --> 01:27:18.120]  se llame memoria inicio, ¿cierto? Bueno, algo así. Y eso es un char pointer, ¿cierto? Pues esto es un
[01:27:18.120 --> 01:27:22.760]  casteo. Recuerden que estamos usando un apuntador entero pues para hacer lo que yo le está diciendo
[01:27:22.760 --> 01:27:31.320]  de desplazarnos de a uno. Y este es el malloc de toda esa memoria que nosotros habíamos pedido,
[01:27:31.320 --> 01:27:37.080]  ¿sí o qué? Pues memoria. Obviamente pues esto es un número de bytes, ¿cierto? Nosotros tenemos
[01:27:37.080 --> 01:27:42.200]  este nombre de variable, pues nada, pues nada, llegan, como ustedes ya tienen eso, llegan y le
[01:27:42.200 --> 01:27:51.960]  pasan eso como parámetro a free y eso es todo, así tal cual. Sí. Ah, y lo otro es que tienen que
[01:27:51.960 --> 01:28:04.560]  imprimir, pues según el ejemplo del profe, pues imprimen goodbye, goodbye. Ya. Y eso es lo que
[01:28:04.560 --> 01:28:10.120]  tienen que imprimir al final. Y como ustedes suelen declarar pues como tal el main como un entero,
[01:28:10.120 --> 01:28:18.120]  ¿cierto? Entonces tienen que retornar un ser. Vamos por retornar algo. Y lo otro es que, por ejemplo,
[01:28:18.120 --> 01:28:23.760]  las funciones que son de convertir de binario a decimal o de decimal a binario ya depende del
[01:28:23.760 --> 01:28:27.960]  valor que ustedes vayan a retornar. Por ejemplo, si ustedes hacen la de binario a decimal, pues
[01:28:27.960 --> 01:28:31.200]  ustedes van a retornar un decimal, entonces pueden devolver, por ejemplo, un entero. Entonces la
[01:28:31.200 --> 01:28:37.160]  función se puede llamar, por ejemplo, entero, binario, a decimal. Como en la otra ustedes van
[01:28:37.160 --> 01:28:41.320]  a devolver una cadena, entonces yo les recomendaría que hagan un void, ¿cierto? ¿Por qué? Porque es
[01:28:41.320 --> 01:28:45.720]  que las cadenas terminan siendo pues básicamente pues uno llega y le coloca pues en la, uno reserva
[01:28:45.720 --> 01:28:53.440]  un espacio en la memoria y la coloca, ¿cierto? Entonces es una operación pues vacía, decimal a binario.
[01:28:57.440 --> 01:28:59.760]  Creo que no tendría más como para decirles hoy.
[01:29:01.680 --> 01:29:08.200]  Ya, este pues era el último taller. Ah, bueno, listo. Lo otro es algo que se me ha olvidado.
[01:29:09.120 --> 01:29:15.640]  Es también que obviamente pues el llamado al malloc puede fallar, ¿cierto? Tranquilamente.
[01:29:15.720 --> 01:29:20.520]  ¿Qué pasa cuando un malloc falla? Pues les devuelve un null. Si les devuelve un null,
[01:29:20.520 --> 01:29:25.320]  entonces ustedes revisan, ah, pues si el inicio es un null, entonces, o sea, pues que no apunta
[01:29:25.320 --> 01:29:32.240]  nada, entonces pueden imprimir error al asignar memoria, ¿cierto? Y pues ya recuerden el otro,
[01:29:32.240 --> 01:29:39.040]  que es el page fault, que si se les pasa, por ejemplo, si la memoria es menor que cero, ¿cierto?
[01:29:39.040 --> 01:29:42.680]  Porque la dirección les puede, les pueden pasar un cero, ¿cierto? Pues sería el inicio de toda
[01:29:42.680 --> 01:29:49.680]  la memoria virtual. Pero también puede pasar que les den un número mayor a 4000, bueno,
[01:29:49.680 --> 01:29:57.000]  en todo caso es 2 a la 32, ¿cierto? Menos 1. Si ustedes les dan un número mayor que esto o menor
[01:29:57.000 --> 01:30:11.480]  que este, entonces, pues ustedes van a decir que esto es un page fault. Listo. Ya, eso es todo.
[01:30:12.680 --> 01:30:23.520]  Muy bueno. Listo, no, yo creo que ya. Cualquier cosita, entonces me escriben en WhatsApp, ahí estoy
[01:30:23.520 --> 01:30:29.200]  pendiente. Yo les ayudo con lo que pueda. Les agradezco, pues, mucho a todos, pues, por haber
[01:30:29.200 --> 01:30:33.920]  asistido a los talleres. Aquí hay gente, pues, que ha asistido, como, desde el principio. Entonces,
[01:30:33.920 --> 01:30:38.680]  les agradezco mucho, pues, ya, entonces, eso sería todo, pues, por mi parte, como mentor de ustedes,
[01:30:38.680 --> 01:30:44.800]  de sistemas operativos. A ustedes les agradezco mucho, pues, por haber asistido, por haberme dado,
[01:30:44.800 --> 01:30:50.840]  pues, la confianza. Creo que ya sería todo. Ahí les queda, pues, la grabación, pues, cualquier
[01:30:50.840 --> 01:30:56.440]  cosa, si necesitan volver a ver y me escriben en WhatsApp cualquier cosita, listo. Que estén muy bien.
[01:30:56.440 --> 01:31:06.760]  Gracias, parce. Gracias, bueno, no gusto. No gusto. Ah, bueno, se llenaron la asistencia. No,
[01:31:06.760 --> 01:31:21.720]  esperen. Por favor. Ah, bueno, yo les doy las directrices de comodas, eso, pues. Ahí ponen,
[01:31:21.720 --> 01:31:28.440]  pues, el correo, el nombre, su documento, ¿cierto? Esta información, pues, no la voy a ver yo,
[01:31:28.440 --> 01:31:36.240]  la va a ver la fundación. Ustedes acá ponen que su programa de sistemas y el mentor que les dio el
[01:31:36.240 --> 01:31:39.200]  taller, pues, se sacaron, están en cada pie, ¿cierto? Pues, había aparecido mi nombre en la
[01:31:39.200 --> 01:31:46.600]  reunión. El nombre de la materia, pues, obviamente, SEO. El inicio fue a las 8, ¿sí o qué? O sea,
[01:31:46.600 --> 01:31:52.880]  a las 20. Y la hora de finalización, pues, fue a las, acá, pues, son las 9.31. Pues, si quieren,
[01:31:52.880 --> 01:31:58.680]  ponen a las 9.30, 9.31, como quieran. Y, pues, ya me colocan una calificación de una 5 y pueden
[01:31:58.680 --> 01:32:05.000]  dejar un comentario como me gustó. O, eh, también de profesor, algo así, ¿sí o qué? Pueden dejar el
[01:32:05.000 --> 01:32:08.480]  comentario que ustedes quieran y mandan el formulario y ya. Eso sería todo.
[01:32:14.200 --> 01:32:18.920]  Entonces, bueno, que les vaya bien en el trabajo. Si, de pronto,
[01:32:18.920 --> 01:32:24.120]  necesitan algo en la lluvia para la sustentación, me dicen, yo les, les ayudo. Pues, no, no,
[01:32:24.120 --> 01:32:28.400]  responderles en el quiz cuando ya lo tengan, sino antes, listo, cuando estén estudiando.
[01:32:28.400 --> 01:32:31.960]  Gracias. De una.
[01:32:31.960 --> 01:32:37.960]  La grabación, gracias a todos por ver, por haber asistido.